parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"prTg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=o;var e=n(require("react")),t=require("@mdx-js/react");function n(e){return e&&e.__esModule?e:{default:e}}function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}const r=e=>(function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,t.mdx)("div",n)}),i={},l="wrapper";function o({components:e,...n}){return(0,t.mdx)(l,a({},i,n,{components:e,mdxType:"MDXLayout"}),(0,t.mdx)("h1",null,"BASIC Tokenization"),(0,t.mdx)("p",null,"Like most BASICs of the 8 and 16-bit microcomputer era, lines of code are\ntokenized before stored in memory. For computers with a small mount of memory\nthis was useful because it often enabled significant space savings. For\ncomputers with a bit more memory (like Retroputer), some space savings can be\ntraded for performance. This can be seen in the tokenization of variables to\npre-compute variable indexes as well as the tokenization of constants to avoid\nconverting a string representation into a number at runtime."),(0,t.mdx)("p",null,"There are several forms of code transformation and tokenization used in\nRetroputer BASIC:"),(0,t.mdx)("ol",null,(0,t.mdx)("li",{parentName:"ol"},"Conversion to uppercase"),(0,t.mdx)("li",{parentName:"ol"},"Removal of extra SPACEs"),(0,t.mdx)("li",{parentName:"ol"},"Numbers in byte range are converted to BYTE tokens"),(0,t.mdx)("li",{parentName:"ol"},"Numbers in word range are converted to WORD tokens"),(0,t.mdx)("li",{parentName:"ol"},"Floating point numbers are converted to REAL tokens"),(0,t.mdx)("li",{parentName:"ol"},"Strings are stored as NUL-terminated character arrays, without any QUOTEs"),(0,t.mdx)("li",{parentName:"ol"},"Keywords are stored as a single byte with bit 7 set (0x80 and higher)"),(0,t.mdx)("li",{parentName:"ol"},"Operators are also treated the same as keywords"),(0,t.mdx)("li",{parentName:"ol"},"Variables have their index pre-calculated, their type condensed into the\nindex's high two bits. The length of the variable name is stored so that\nwe can quickly jump past during execution. Variable names are NOT stored\nwith NUL terminators."),(0,t.mdx)("li",{parentName:"ol"},"End-of-line indicator")),(0,t.mdx)("h2",null,"Conversion to uppercase"),(0,t.mdx)("p",null,"The first step of the tokenization process is to convert all non-string\ncharacters to uppercase. This simplifies keyword lookups, and also ensures that\na variable name is easier to index (no need to account for lowercase names)."),(0,t.mdx)("p",null,'Because strings must be accounted for, it\'s during this phase that quotes are\nchecked to ensure that all opening quotes have an ending quote. If a quote is\nfound to be missing, BASIC will raise a "EXPECTED A QUOTE" error. Should this\noccur when entering a line into program storage, ',(0,t.mdx)("em",{parentName:"p"},"the line will not be stored"),"."),(0,t.mdx)("h2",null,"Removal of extra SPACEs"),(0,t.mdx)("p",null,"Whitespace in BASIC is not significant, and so any unnecessary spaces are\nremoved. This is to save on memory, but also to increase performance speed\nduring runtime (the more SPACEs must be consumed, the slower code would run)."),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},"Note: Removal of extra spaces has the unfortunate side-effect of losing any\nindentation of code. You can use ",(0,t.mdx)("inlineCode",{parentName:"p"},":")," statement separators to keep indentation\nat the cost of execution speed.")),(0,t.mdx)("p",null,"BASIC will match keywords and other tokens greedily, and so SPACEs are not\nabsolutely required. As such, SPACEs can be omitted in many places to save even\nmore memory at the expense of readibility."),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},"Note: SPACEs are not removed from string literals.")),(0,t.mdx)("h2",null,"Tokenization of Numbers"),(0,t.mdx)("p",null,"In many early versions of BASIC, numers were stored as strings, requiring\nparsing every time they were encountered. This meant that variables were often\nfar faster than constants. While magic numbers should not be encouraged, there\nare often cases where storing ",(0,t.mdx)("inlineCode",{parentName:"p"},"0"),", ",(0,t.mdx)("inlineCode",{parentName:"p"},"1"),", and other sentinel values make sense."),(0,t.mdx)("p",null,"Retroputer BASIC tries to conserve as much memory as possible when tokenizing\nnumbers. If a number can be stored as a byte, it will be, for example."),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",a({parentName:"tr"},{align:null}),"Range"),(0,t.mdx)("th",a({parentName:"tr"},{align:null}),"Token"),(0,t.mdx)("th",a({parentName:"tr"},{align:null}),"Storage"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"0x00-0xFF"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"0xFF"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"Byte")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"0x100-0xFFFF"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"0xFE"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"Word")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"32-bit value"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"0xFC"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"Long Word (@todo)")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"Otherwise..."),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"0xF9"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"64-bit floating point (@todo)")))),(0,t.mdx)("p",null,"This means that for small digits, the tokenized storage required will be more\nthan the single digit would require. For example, ",(0,t.mdx)("inlineCode",{parentName:"p"},"0")," takes two bytes to store\n(",(0,t.mdx)("inlineCode",{parentName:"p"},"0xFF 0x00"),"). However ",(0,t.mdx)("inlineCode",{parentName:"p"},"255")," requires one less byte (",(0,t.mdx)("inlineCode",{parentName:"p"},"0xFF 0xFF"),"). Floating\npoint values are also sometimes subject to this as well (where ",(0,t.mdx)("inlineCode",{parentName:"p"},"1.5")," takes more\nspace when tokenized)."),(0,t.mdx)("p",null,"The storage tradeoff is considered worthwhile, however, because it grants a\nlarge performance improvement during runtime. Instead of having to convert\nnumbers each time they are encountered, they are encountered in a form that can\nbe immediately used by the CPU. This improves performance considerably,\nespecially for larger numbers and floating-point numbers."),(0,t.mdx)("h2",null,"Tokenization of String literals"),(0,t.mdx)("p",null,"String literals are stored in a format that makes them easy to print and pass\nto other functions in the standard library (like ",(0,t.mdx)("inlineCode",{parentName:"p"},"STRCMP"),"). These are stored\nas NUL-terminated character arrays, without any surrounding QUOTEs. When\nLISTed, BASIC will wrap strings with QUOTEs to reflect the original intent."),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},"NOTE: when scanning, string literals must be scanned character by character.\nThis means that long strings take more time to parse during runtime.")),(0,t.mdx)("p",null,"String literals are stored with token ",(0,t.mdx)("inlineCode",{parentName:"p"},"0xFB")," (Code String). This is used to\nsignify to the runtime environment that, absent any string manipulation, the\ninterpreter can use the string directly from code, thus saving space on the\ndata heap."),(0,t.mdx)("h2",null,"Tokenization of Keywords and Operators"),(0,t.mdx)("p",null,"All keywords and operators are condensed into a single byte token with bit 7\nset. This means that keywords and operator tokens are easily identified\nbecause they will be 0x80 or higher. This makes it easy to construct vector\ntables to speed up execution during runtime."),(0,t.mdx)("p",null,"Retroputer BASIC, like many BASICs of the era, will match keywords that exist\nat the start of a variable name. (Some BASICs would match even in the middle of\na variable name.) This means that it's impossible to have a variable named\n",(0,t.mdx)("inlineCode",{parentName:"p"},"TOTAL")," because Retroputer will see ",(0,t.mdx)("inlineCode",{parentName:"p"},"TO")," as a keyword. However, ",(0,t.mdx)("inlineCode",{parentName:"p"},"SCORE")," and\n",(0,t.mdx)("inlineCode",{parentName:"p"},"GOAT")," are valid names, even though because they ",(0,t.mdx)("em",{parentName:"p"},"contain")," keywords (",(0,t.mdx)("inlineCode",{parentName:"p"},"OR")," and\n",(0,t.mdx)("inlineCode",{parentName:"p"},"AT"),", respectively) they don't ",(0,t.mdx)("em",{parentName:"p"},"start")," with a keyword."),(0,t.mdx)("p",null,"Variable names in Retroputer BASIC are only significant to two characters, and\nvariables can only be of the form ",(0,t.mdx)("inlineCode",{parentName:"p"},"[A-Z][A-Z0-9]*"),". The first two chracters are\nused to calculate the variable index into variable memory (starting at\n",(0,t.mdx)("inlineCode",{parentName:"p"},"0x02000"),"). This means that every variable reference takes up four more bytes\nthan the name itself. This takes up a lot of space, but makes it trivial for\nBASIC to look up a variable quickly during runtime."),(0,t.mdx)("p",null,"The format when stored looks like this:"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",a({parentName:"tr"},{align:null}),"0x00"),(0,t.mdx)("th",a({parentName:"tr"},{align:null}),"0x01"),(0,t.mdx)("th",a({parentName:"tr"},{align:null}),"0x02"),(0,t.mdx)("th",a({parentName:"tr"},{align:null}),"0x03"),(0,t.mdx)("th",a({parentName:"tr"},{align:null}),"0x04"),(0,t.mdx)("th",a({parentName:"tr"},{align:null}),"0x05..."))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"0xFA"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"high index & type"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"low index"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"length"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"char 1"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"char 2...")))),(0,t.mdx)("p",null,"The type of a variable is stored in the top three bits of the index as follows:"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",a({parentName:"tr"},{align:null}),"Bits"),(0,t.mdx)("th",a({parentName:"tr"},{align:null}),"Type"),(0,t.mdx)("th",a({parentName:"tr"},{align:null}),"Sigil"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",a({parentName:"tr"},{align:null}),(0,t.mdx)("inlineCode",{parentName:"td"},"000")),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"Integer"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"N/A")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",a({parentName:"tr"},{align:null}),(0,t.mdx)("inlineCode",{parentName:"td"},"001")),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"String"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),(0,t.mdx)("inlineCode",{parentName:"td"},"$"))),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",a({parentName:"tr"},{align:null}),(0,t.mdx)("inlineCode",{parentName:"td"},"010")),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"Floating Point number"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),(0,t.mdx)("inlineCode",{parentName:"td"},"#"))),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",a({parentName:"tr"},{align:null}),(0,t.mdx)("inlineCode",{parentName:"td"},"011")),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"FN or SUB"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"N/A")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",a({parentName:"tr"},{align:null}),(0,t.mdx)("inlineCode",{parentName:"td"},"100")),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"Array of Integers"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),(0,t.mdx)("inlineCode",{parentName:"td"},"()"))),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",a({parentName:"tr"},{align:null}),(0,t.mdx)("inlineCode",{parentName:"td"},"101")),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"Array of Strings"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),(0,t.mdx)("inlineCode",{parentName:"td"},"$()"))),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",a({parentName:"tr"},{align:null}),(0,t.mdx)("inlineCode",{parentName:"td"},"110")),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"Array of Floating Point numbers"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),(0,t.mdx)("inlineCode",{parentName:"td"},"#()"))),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",a({parentName:"tr"},{align:null}),(0,t.mdx)("inlineCode",{parentName:"td"},"111")),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"Unused"),(0,t.mdx)("td",a({parentName:"tr"},{align:null}),"N/A")))),(0,t.mdx)("p",null,"This information enables BASIC to quickly calculate the correct base in storage\nto either lookup or store a viarable value during runtime."),(0,t.mdx)("p",null,"When LISTed, the corresponding sigil is rendered to indicate the originally\nindicated type."),(0,t.mdx)("h2",null,"End-of-line"),(0,t.mdx)("p",null,'A NUL byte is added to the end of each tokenized line. This is used to quickly\nidentify during runtime when the end of the line has been reached. This is a\ndifferent token from the "End of Statement" token, which has a slightly\ndifferent semantic meaning than does the end of the line.'))}o.isMDXComponent=!0;
},{"react":"SAdv","@mdx-js/react":"QaRW"}]},{},[], null)
//# sourceMappingURL=/tokenization.e4b78fe3.js.map
{"version":3,"sources":["../../../docs/programming-retroputer/asm/accessing-memory.md"],"names":["makeShortcode","name","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":"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","file":"accessing-memory.77a165ff.js","sourceRoot":"../src/www/simple","sourcesContent":["/* @jsx mdx */\nimport React from 'react';\nimport { mdx } from '@mdx-js/react'\n/* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1>{`Accessing Memory`}</h1>\n    <p>{`Reading from and writing to memory is accomplished using the `}<inlineCode parentName=\"p\">{`LD`}</inlineCode>{` `}{`(`}{`LOAD`}{`)`}{` and `}<inlineCode parentName=\"p\">{`ST`}</inlineCode>{` `}{`(`}{`STORE`}{`)`}{` instructions respectively. These are the only two instructions that can read from and modify memory. All other instructions deal either with registers or with I/O ports.`}</p>\n    <h2>{`Loading a Constant`}</h2>\n    <p>{`When one needs to load a register with a specific value, but doesn't want to assign the value a location in memory, the immediate form of `}<inlineCode parentName=\"p\">{`LD`}</inlineCode>{` can be used. Technically it's very similar to any other method of loading data from memory into a register, just that the data is encoded within the instruction itself.`}</p>\n    <p>{`Let's say we wanted to change the value of `}<inlineCode parentName=\"p\">{`A`}</inlineCode>{` to the value of `}<inlineCode parentName=\"p\">{`0x1234`}</inlineCode>{`. We can use the following instruction:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`ld a, 0x1234\n`}</code></pre>\n    <blockquote>\n      <h3 parentName=\"blockquote\">{`NOTE`}</h3>\n      <p parentName=\"blockquote\">{`The assembler allows expressions too! So you could use `}<inlineCode parentName=\"p\">{`ld a, 0x1200 + 0x34`}</inlineCode>{` to accomplish the same result.`}</p>\n    </blockquote>\n    <h2>{`Loading a Value from a Variable`}</h2>\n    <p>{`Typically programs will store information in a variable and will need to retrieve that information later. Variables are allocated a specific amount of memory in a segment based upon the size and width of the data itself. For example, a byte takes up one byte in a segment, whereas an array of 256 words will take up 512 bytes.`}</p>\n    <p>{`Assuming the variable in question is a byte or word variable, it's easy to load data from it into a register using the `}<strong parentName=\"p\">{`absolute addressing mode`}</strong>{`.`}</p>\n    <p>{`First, let's imagine the following data segment -- it has one variable defined named `}<inlineCode parentName=\"p\">{`lives`}</inlineCode>{` -- this represents the number of lives a player has left in a game.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`.segment data 0x03000 {\n  lives: .byte 0x03\n}\n`}</code></pre>\n    <p>{`Next, we might want to access the variable in order to see if the game is truly over. We use `}<strong parentName=\"p\">{`absolute addressing mode`}</strong>{` to accomplish this. Absolute addresses are simply 19-bit numbers that refer to a specific memory address. 19 bits is sufficient to address the entirety of Retroputer's memory space. Because the address isn't relative to anything else `}{`(`}{`other than `}<inlineCode parentName=\"p\">{`0`}</inlineCode>{`)`}{`, the addressing mode is called `}<strong parentName=\"p\">{`absolute`}</strong>{`.`}</p>\n    <p>{`To indicate that you're using `}<strong parentName=\"p\">{`absolute addressing`}</strong>{`, one uses square brackets in the `}<inlineCode parentName=\"p\">{`LD`}</inlineCode>{` statement, like so:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`.segment code 0x02000 {\n  ld al, [data.lives]\n}\n`}</code></pre>\n    <blockquote>\n      <h3 parentName=\"blockquote\">{`IMPORTANT: Register Width Matters!`}</h3>\n      <p parentName=\"blockquote\">{`It's critical to match the register and the width of the data you're trying to access. `}<inlineCode parentName=\"p\">{`ld a, [0x00000]`}</inlineCode>{` will load the bytes at addresses `}<inlineCode parentName=\"p\">{`0x00000`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`0x00001`}</inlineCode>{` and deposit them into the high and low bytes of `}<inlineCode parentName=\"p\">{`A`}</inlineCode>{` respectively. `}<inlineCode parentName=\"p\">{`ld al, [0x00000]`}</inlineCode>{`, however will load only the byte at address `}<inlineCode parentName=\"p\">{`0x00000`}</inlineCode>{` and deposit it into the low byte of `}<inlineCode parentName=\"p\">{`A`}</inlineCode>{` `}{`(`}{`known as `}<inlineCode parentName=\"p\">{`AL`}</inlineCode>{`)`}{`.`}</p>\n    </blockquote>\n    <p>{`The above statement will actually be turned into `}<inlineCode parentName=\"p\">{`ld al, [0x03000]`}</inlineCode>{` by the assembler -- it will keep track of the fact that `}<inlineCode parentName=\"p\">{`data.lives`}</inlineCode>{` actually points to address `}<inlineCode parentName=\"p\">{`0x03000`}</inlineCode>{` for us.`}</p>\n    <h2>{`Storing Data into a Variable`}</h2>\n    <p>{`Storing data into a variable works similarly to how you load data from a variable. The order of operands is swapped around to indicate that the `}<em parentName=\"p\">{`source`}</em>{` and `}<em parentName=\"p\">{`target`}</em>{` is different, however.`}</p>\n    <p>{`Let's say we wanted to decrement the number of lives remaining and store that back into the variable we've already defined. We can do that like so:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`dec al\nst [data.lives], al\n`}</code></pre>\n    <p>{`This will write the new value in `}<inlineCode parentName=\"p\">{`AL`}</inlineCode>{` to memory address `}<inlineCode parentName=\"p\">{`0x03000`}</inlineCode>{` which happens to be the variable `}<inlineCode parentName=\"p\">{`lives`}</inlineCode>{`.`}</p>\n    <blockquote>\n      <h3 parentName=\"blockquote\">{`IMPORTANT: Register Width Matters!`}</h3>\n      <p parentName=\"blockquote\">{`Just like the `}<inlineCode parentName=\"p\">{`LD`}</inlineCode>{` statement, the size of the register you're using with `}<inlineCode parentName=\"p\">{`ST`}</inlineCode>{` matters. If you want to write a single byte to memory, be sure to use a single-byte register. If you want to write two bytes at once, use a word-sized register. If you fail to use the correct width, you could inadvertently overwrite memory that you didn't intend to change.`}</p>\n    </blockquote>\n    <h2>{`Loading Data from an Array`}</h2>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;\n"]}
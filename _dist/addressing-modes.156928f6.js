parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"eMjH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=o;var e=t(require("react")),n=require("@mdx-js/react");function t(e){return e&&e.__esModule?e:{default:e}}function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}const d=e=>(function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,n.mdx)("div",t)}),i={},l="wrapper";function o({components:e,...t}){return(0,n.mdx)(l,a({},i,t,{components:e,mdxType:"MDXLayout"}),(0,n.mdx)("h1",null,"Addressing Modes"),(0,n.mdx)("p",null,"Without the ability to address memory, the 6516 CPU would be very limited, since it only has a few registers with which to store and process data. Addressing memory, however, is often more complicated than one might initially imagine, since one needs to be able to effectively reference data on the stack, perform array indexing operations, and also perform pointer operations."),(0,n.mdx)("p",null,"The following addressing modes are supported by the 6516."),(0,n.mdx)("h2",null,"Immediate ","(","8/16",")"),(0,n.mdx)("p",null,"This mode applies only to the ",(0,n.mdx)("inlineCode",{parentName:"p"},"LD")," instruction and is used to quickly transfer constants into a register. The width of the register determines the length of the instruction required to fit the constant value."),(0,n.mdx)("pre",null,(0,n.mdx)("code",a({parentName:"pre"},{className:"language-text"}),"ld a, 1234     # four bytes required for this instruction\nld al, 65      # three bytes required for this instruction\n")),(0,n.mdx)("h2",null,"Relative ","(","8/16",")"),(0,n.mdx)("p",null,"Relative addressing is used only for instructions that affect the program's control flow, namely ",(0,n.mdx)("inlineCode",{parentName:"p"},"BR"),", ",(0,n.mdx)("inlineCode",{parentName:"p"},"CALL"),", and ",(0,n.mdx)("inlineCode",{parentName:"p"},"LOOP")," ","(","and short variants",")",". The address is relative to the ",(0,n.mdx)("em",{parentName:"p"},"next")," instruction."),(0,n.mdx)("blockquote",null,(0,n.mdx)("h4",{parentName:"blockquote"},(0,n.mdx)("strong",{parentName:"h4"},"Note")),(0,n.mdx)("p",{parentName:"blockquote"},"PC will be pointing at the next instruction, so a ",(0,n.mdx)("inlineCode",{parentName:"p"},"BR -4")," will enter an infinite loop. ","(","For a short branch, ",(0,n.mdx)("inlineCode",{parentName:"p"},"BRS -3")," will do the same.",")")),(0,n.mdx)("p",null,"A short branch can jump within -128 to 127 bytes from the next instruction. A long branch can jump within -32768 to 32767 bytes."),(0,n.mdx)("h2",null,"Absolute"),(0,n.mdx)("p",null,"When loading data, the operand specifies the full 19-bits required to reference any byte within memory space. When branching, the operand specifies 16 bits, which is sufficient for reading and then branching to any location in the first bank ","(","which is the only bank that supports code execution",")","."),(0,n.mdx)("pre",null,(0,n.mdx)("code",a({parentName:"pre"},{className:"language-text"}),"ld a, [0x01234]    # load the word at address 0x01234\nld al, [0x7FFFF]   # load the last byte of memory\nbr [0x2000]        # jump to address pointed to by the word at 0x2000\n")),(0,n.mdx)("h3",null,"Indexing"),(0,n.mdx)("p",null,"The address can be indexed by either ",(0,n.mdx)("inlineCode",{parentName:"p"},"X")," or ",(0,n.mdx)("inlineCode",{parentName:"p"},"Y")," or both."),(0,n.mdx)("pre",null,(0,n.mdx)("code",a({parentName:"pre"},{className:"language-text"}),"ld x, 0x1000\nld y, 0x0010\nld al, [0x10000, x]     # load the byte from 0x11000\nld al, [0x10000, y]     # load the byte from 0x10010\nld al, [0x10000, x, y]  # load the byte from 0x11010\n")),(0,n.mdx)("p",null,"The indexing is always by byte; the width of the destination register has no effect on it."),(0,n.mdx)("h2",null,"Indirect Absolute"),(0,n.mdx)("p",null,"Indirect addressing mode allows one to load data from a location that's pointed at by an absolute address in memory."),(0,n.mdx)("p",null,"When loading or storing data, the absolute address is encoded in 19 bitsâ€”enough to reference every byte of memory. The word that is located at the specified location is then combined with the page of the original absolute address, resulting in a new indirect address. This has the result that you can only access memory indirectly within the same bank as the address through which you are indirecting."),(0,n.mdx)("p",null,"When branching, the absolute address is encoded in 16 bits. The value at that address is then used to look up the new target address. This means that you can only indirect branch within the lowest bank of memory."),(0,n.mdx)("h3",null,"Indexing"),(0,n.mdx)("p",null,"You can index by ",(0,n.mdx)("inlineCode",{parentName:"p"},"X")," or ",(0,n.mdx)("inlineCode",{parentName:"p"},"Y")," ","(","or both",")"," when using the indirect addressing mode, but the final address is determined by the register used for indexing."),(0,n.mdx)("p",null,"When indexing by ",(0,n.mdx)("inlineCode",{parentName:"p"},"X"),", the value of ",(0,n.mdx)("inlineCode",{parentName:"p"},"X")," is added to the absolute address. This enables the ability to index a vector table, for example. The word at the absolute address ",(0,n.mdx)("em",{parentName:"p"},"plus")," the ",(0,n.mdx)("inlineCode",{parentName:"p"},"X")," offset will be used as the target address."),(0,n.mdx)("p",null,"When indexing by ",(0,n.mdx)("inlineCode",{parentName:"p"},"Y"),", however, the value of ",(0,n.mdx)("inlineCode",{parentName:"p"},"Y")," is added to the indirected address. This makes it easier to dereference array indices when indirecting through a pointer."),(0,n.mdx)("p",null,"When combining the two, ",(0,n.mdx)("inlineCode",{parentName:"p"},"X")," is first applied to the absolute address, and then ",(0,n.mdx)("inlineCode",{parentName:"p"},"Y")," is applied to the resulting indirect address."),(0,n.mdx)("pre",null,(0,n.mdx)("code",a({parentName:"pre"},{className:"language-text"}),"ld a, 0x1000  \nst [0x02000], a        # address 0x02000 has the value 0x1000\nst [0x03000], a        # so does 0x03000\nld al, 65\nst [0x01000], al       # address 0x01000 has the value 65\nst [0x01010], al\n\nld x, 0x1000\nld y, 0x0010\n\nld al, <0x02000>       # load a with 65 (0x02000 -> 0x01000 = 65)\nld al, <0x02000, x>    # load a with 65 (0x02000 + 0x1000 -> 0x03000 -> 0x01000 = 65)\nld al, <0x02000>, y    # load a with 65 (0x02000 -> 0x03000 + 0x10 -> 0x01010 = 65)\nld al, <0x02000, x>, y # load a with 65 (0x02000 + 0x1000 -> 0x03000 + 0x10 -> 0x01010 = 65)\n")),(0,n.mdx)("h2",null,"Relative BP"),(0,n.mdx)("p",null,"When writing functions that take a large number of arguments or a large amount of data, it's useful to reference information stored locally on the stack. This addressing mode enables one to specify an offset from ",(0,n.mdx)("inlineCode",{parentName:"p"},"BP"),", and then reads data from that address."),(0,n.mdx)("p",null,"When branching, this mode only makes sense if the address on the stack points at another function."),(0,n.mdx)("p",null,"The offset from ",(0,n.mdx)("inlineCode",{parentName:"p"},"BP")," can be -32768 to 32767. Given the typical size of the stack, however, this is rarely ever an issue."),(0,n.mdx)("pre",null,(0,n.mdx)("code",a({parentName:"pre"},{className:"language-text"}),"ld al, [bp]        # load the byte at BP\nld al, [bp+-02]    # load the byte at BP - 2 (the + is required syntax)\n")),(0,n.mdx)("h3",null,"Indexing"),(0,n.mdx)("p",null,"Indexing ",(0,n.mdx)("inlineCode",{parentName:"p"},"BP")," is also possible, and acts the same as with absolute addressiong."),(0,n.mdx)("pre",null,(0,n.mdx)("code",a({parentName:"pre"},{className:"language-text"}),"ld al, [bp+-10, x]    #start at 10 bytes before BP, index by x, and load\nld al, [bp+-10, y]\nld al, [bp+-10, x, y]\n")),(0,n.mdx)("h2",null,"Indirect Relative BP"),(0,n.mdx)("p",null,"As with indrect absolute addressing, one can indirect through a relative ",(0,n.mdx)("inlineCode",{parentName:"p"},"BP")," address:"),(0,n.mdx)("pre",null,(0,n.mdx)("code",a({parentName:"pre"},{className:"language-text"}),"ld al, <bp+-2>      # load the byte from the address specified at BP+-2\n")),(0,n.mdx)("h3",null,"Indexing"),(0,n.mdx)("p",null,"Indexing with indirect relative ",(0,n.mdx)("inlineCode",{parentName:"p"},"BP")," works the same way as indirect absolute indexing."),(0,n.mdx)("pre",null,(0,n.mdx)("code",a({parentName:"pre"},{className:"language-text"}),"ld al, <bp+-10, x>\nld al, <bp+-10>, y\nld al, <bp+-10, x>, y\n")),(0,n.mdx)("h2",null,"Absolute D,X"),(0,n.mdx)("p",null,"This mode is used to enable the combinations of ",(0,n.mdx)("inlineCode",{parentName:"p"},"D")," and ",(0,n.mdx)("inlineCode",{parentName:"p"},"X")," to specify any address in the memory space. ",(0,n.mdx)("inlineCode",{parentName:"p"},"D")," and ",(0,n.mdx)("inlineCode",{parentName:"p"},"X")," are combined in such a way that they form a 19-bit address, which can then be indexed and offset."),(0,n.mdx)("p",null,"The operation for determining the final operation looks like this:"),(0,n.mdx)("p",null,"$$\n\\begin{alignedat}{1}\n& D_f & D_e & D_d & D_c & D_b & D_a & D_9 & D_8\n& D_7 & D_6 & D_5 & D_4 & D_3 & D_2 & D_1 & D_0 &   &   &   ","\\"),(0,n.mdx)("ul",null,(0,n.mdx)("li",{parentName:"ul"},"&   &   &   & X",(0,n.mdx)("em",{parentName:"li"},"f & X_e & X_d & X_c & X_b & X_a & X_9 & X_8 & X_7 & X_6 & X_5 & X_4 & X_3 & X_2 & X_1 & X_0","\\","\n\\hline\n& A"),"{12} & A",(0,n.mdx)("em",{parentName:"li"},"{11} & A"),"{10} & A_f & A_e & A_d & A_c & A_b & A_a & A_9 & A_8 & A_7 & A_6 & A_5 & A_4 & A_3 & A_2 & A_1 & A_0\n\\end{alignedat}\n$$")),(0,n.mdx)("blockquote",null,(0,n.mdx)("h4",{parentName:"blockquote"},"Note"),(0,n.mdx)("p",{parentName:"blockquote"},"If ",(0,n.mdx)("inlineCode",{parentName:"p"},"X")," is not supplied, ",(0,n.mdx)("inlineCode",{parentName:"p"},"0")," is assumed. As such ",(0,n.mdx)("inlineCode",{parentName:"p"},"ld al, [d]")," will load from the address",(0,n.mdx)("inlineCode",{parentName:"p"},"d<<3"),".")),(0,n.mdx)("p",null,"There's no established requirement to determining which bits should go in ",(0,n.mdx)("inlineCode",{parentName:"p"},"D")," and which should go in ",(0,n.mdx)("inlineCode",{parentName:"p"},"X"),", so use whatever makes sense for the algorithm at hand. Typically, however, you'll usually load the top 16 bits of the address in ",(0,n.mdx)("inlineCode",{parentName:"p"},"D")," and the bottom three bits in ",(0,n.mdx)("inlineCode",{parentName:"p"},"X")," to ensure that you can continue to index by ",(0,n.mdx)("inlineCode",{parentName:"p"},"X")," should you need to do so."),(0,n.mdx)("p",null,"Often this looks like this:"),(0,n.mdx)("pre",null,(0,n.mdx)("code",a({parentName:"pre"},{className:"language-text"}),'.segment data 0x03000 {\n    hello: .string "Hello, world"\n           .byte 0\n}\n\n.segment code 0x02000 {\n    ld d, data.hello >> 3\n    ld x, data.hello & 7\n    ld al, [d, x]           # al is now "H"\n}\n')),(0,n.mdx)("h3",null,"Indexing"),(0,n.mdx)("p",null,"Should you wish to index, you can adjust ",(0,n.mdx)("inlineCode",{parentName:"p"},"X"),", or index additionally with ",(0,n.mdx)("inlineCode",{parentName:"p"},"Y"),"."),(0,n.mdx)("h3",null,"Offsetting"),(0,n.mdx)("p",null,"Like in Relative ",(0,n.mdx)("inlineCode",{parentName:"p"},"BP")," addressing, you can add an additional constant offset to ",(0,n.mdx)("inlineCode",{parentName:"p"},"D"),"."),(0,n.mdx)("pre",null,(0,n.mdx)("code",a({parentName:"pre"},{className:"language-text"}),"ld al, [d+1000, x]\n")),(0,n.mdx)("h2",null,"Indirect D,X"),(0,n.mdx)("p",null,"It is possible to indirect through any word in memory space using ",(0,n.mdx)("strong",{parentName:"p"},"Indirect D,X"),". Just like any mode of indirection, the resulting bank will always be the same as the original absolute address ","(","or ",(0,n.mdx)("inlineCode",{parentName:"p"},"0")," when branching",")",". The method for determining the initial absolute address is the same as ",(0,n.mdx)("strong",{parentName:"p"},"Absolute D,X"),"."),(0,n.mdx)("pre",null,(0,n.mdx)("code",a({parentName:"pre"},{className:"language-text"}),'.segment strings 0x50000 {\n    hello: .string "Hello, World"\n           .byte 0\n    score: .string "Score"\n           .byte 0\n    level: .string "Level"\n           .byte 0\n    vectors:\n        .word[3] hello, score, level\n}\n\n.segment code 0x02000 {\n    ld d, strings.vectors >> 3\n    ld x, string.vectors & 7\n    ld al, <d+2,x>           # al has "S"\n}\n')),(0,n.mdx)("h3",null,"Indexing"),(0,n.mdx)("p",null,"Indexing with Indirect D, X is similar to indirecting with any other addressing mode in that ",(0,n.mdx)("inlineCode",{parentName:"p"},"Y")," is applied after determining the indirect address."),(0,n.mdx)("pre",null,(0,n.mdx)("code",a({parentName:"pre"},{className:"language-text"}),"ld al, <d,x>, y\n")),(0,n.mdx)("h3",null,"Offsetting"),(0,n.mdx)("p",null,"A constant offset can be added to ",(0,n.mdx)("inlineCode",{parentName:"p"},"D"),":"),(0,n.mdx)("pre",null,(0,n.mdx)("code",a({parentName:"pre"},{className:"language-text"}),"ld al, <d+2, x>\n")))}o.isMDXComponent=!0;
},{"react":"SAdv","@mdx-js/react":"QaRW"}]},{},[], null)
//# sourceMappingURL=/addressing-modes.156928f6.js.map
parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"izMa":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=d;var e=a(require("react")),t=require("@mdx-js/react");function a(e){return e&&e.__esModule?e:{default:e}}function n(){return(n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}const r=e=>(function(a){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,t.mdx)("div",a)}),l={},m="wrapper";function d({components:e,...a}){return(0,t.mdx)(m,n({},l,a,{components:e,mdxType:"MDXLayout"}),(0,t.mdx)("h1",null,"Calling Convention"),(0,t.mdx)("h2",null,"Volatile and Preserved Registers"),(0,t.mdx)("p",null,"When calling a subroutine, it is expected that some registers will be preserved, whereas others will be destroyed."),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Register"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Typical Use"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Preserved?"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"By Whom?"))),(0,t.mdx)("tbody",{parentName:"table"})),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"A"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"General Purpose Register"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Yes"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Subroutine"))),(0,t.mdx)("tbody",{parentName:"table"})),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"B"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"General Purpose Register"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Yes"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Subroutine"))),(0,t.mdx)("tbody",{parentName:"table"})),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Counter"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"No"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"})))),(0,t.mdx)("tbody",{parentName:"table"})),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"D"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Data Access Register & Return Value"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"No"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"})))),(0,t.mdx)("tbody",{parentName:"table"})),(0,t.mdx)("table",null,(0,t.mdx)("thead",null,(0,t.mdx)("tr",null,(0,t.mdx)("th",{style:"text-align:left"},"X"),(0,t.mdx)("th",{style:"text-align:left"},(0,t.mdx)("p",null,"Index Register / Low Pointer Address /"),(0,t.mdx)("p",null,"Low Pointer Address Return Value")),(0,t.mdx)("th",{style:"text-align:left"},"No"),(0,t.mdx)("th",{style:"text-align:left"}))),(0,t.mdx)("tbody",null)),"| Y | Index Register / Low Pointer address | No |  | | :--- | :--- | :--- | :--- |",(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"BP"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Base Pointer"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Yes"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Subroutine"))),(0,t.mdx)("tbody",{parentName:"table"})),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SP"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Stack Pointer"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Yes"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Subroutine"))),(0,t.mdx)("tbody",{parentName:"table"})),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Flags"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Processor Status"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Yes"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Subroutine"))),(0,t.mdx)("tbody",{parentName:"table"})),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"PC"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Program Counter"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Yes"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"CPU"))),(0,t.mdx)("tbody",{parentName:"table"})),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"MM"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Memory Map"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Yes"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Subroutine"))),(0,t.mdx)("tbody",{parentName:"table"})),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"MP"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Memory Pointer"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Yes"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"CPU"))),(0,t.mdx)("tbody",{parentName:"table"})),(0,t.mdx)("p",null,"Because the 6516 has several registers, the calling convention does use some of them when passing parameters to subroutines. Any remaining parameters are passed on the stack."),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Parameter Index ","(","Word",")"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Register"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"1"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"D")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"2"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"C")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"3+"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"BP+-2 ","(","...",")")))),(0,t.mdx)("blockquote",null,(0,t.mdx)("h3",{parentName:"blockquote"},"IMPORTANT"),(0,t.mdx)("p",{parentName:"blockquote"},"Aggregates ","(","8-bit values",")"," are passed in using ",(0,t.mdx)("em",{parentName:"p"},"both")," the low and high portions of the corresponding 16-bit register. As such, the parameter ordering changes to the following: DL, DH, CL, CH, ",(0,t.mdx)("em",{parentName:"p"},"stack"),".")),(0,t.mdx)("h2",null,"Pointer Parameters"),(0,t.mdx)("p",null,"When a parameter needs to be a pointer to some data, the form ",(0,t.mdx)("inlineCode",{parentName:"p"},"R[,IDX]")," is used ","(","where ",(0,t.mdx)("inlineCode",{parentName:"p"},"IDX")," is an index register",")",". On the stack, a similar pattern is used where ",(0,t.mdx)("inlineCode",{parentName:"p"},"BP+-2")," would refer to the top 16 bits and ",(0,t.mdx)("inlineCode",{parentName:"p"},"BP+-4")," would refer to the bottom 16 bits of an address ","(","which is 19 bits",")","."),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Parameter Index ","(","Word",")"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Register"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"1"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"D, X")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"2"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"C, Y")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"3+"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"BP+-2, BP+-4 ","(","...",")")))),(0,t.mdx)("h2",null,"Integer Return Value"),(0,t.mdx)("p",null,"The return value of a subroutine is returned through the ",(0,t.mdx)("inlineCode",{parentName:"p"},"D")," register for 16-bit values ","(","or ",(0,t.mdx)("inlineCode",{parentName:"p"},"DL")," for 8-bit values",")","."),(0,t.mdx)("h2",null,"Pointer Return Value"),(0,t.mdx)("p",null,"Should a return value need to be a pointer to another memory address, the result must be in ",(0,t.mdx)("inlineCode",{parentName:"p"},"D,X")," where ",(0,t.mdx)("inlineCode",{parentName:"p"},"D")," contains the top 16-bits of the address and ",(0,t.mdx)("inlineCode",{parentName:"p"},"X")," contains the bottom 16-bits address such that ",(0,t.mdx)("inlineCode",{parentName:"p"},"( D << 3 ) | X")," results in the desired address."),(0,t.mdx)("h2",null,"In Practice"),(0,t.mdx)("p",null,"Let's go over a few of some typical subroutines and how one calls them."),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),'.segment data 0x03000 {\n    str: .string "Hello, World"\n         .byte 0x00\n}\n.segment code 0x02000 {\n\n    ld d, data.str >> 3    # passing {ptr} str\n    ld x, data.str & 0x7   # passing {ptr} str\n    ld cl, 10              # passing {byte} col\n    exc c                  # swap bytes\n    ld cl, 12              # passing {byte} row\n    calls print\n    brk\n\n    ##\n    ## Displays a string at the desired row and column.\n    ##\n    ## @param {ptr} str - the string to display\n    ## @param {byte} row - the row at which to start displaying it\n    ## @param {byte} col - the column at which to start displaying it\n    ## @affects X, Y\n    ## @returns {byte} newRow - the ending row\n    ## @returns {byte} newCol - the ending column\n    print: {\n    pre:\n        push b\n        push a\n        pushf\n    main:\n        mov a, cl                # calculate addr = row * 32 + col\n        shl a, 5                 #           a    = cl * 32  + ch\n        mov b, c\n        clr c # clear carry, so shr isn\'t sign extending\n        shr b, 8\n        add a, b\n\n        mov y, a                 # y is used as the screen pos\n        ld a, 0x00FF             # color\n        ld bl, [D,X]             # load character        \n        while !z do {\n            st [0x10000,y], bl   # write to screen\n            st [0x11000,y], al   # foreground color\n            exc a\n            st [0x12000,y], al   # background color\n            exc a\n            inc x\n            inc y\n            ld bl, [D,X]         # load next character\n            cmp bl, 0x00         # is it NULL?\n        }\n\n        mov a, y\n        and a, 0b11111\n        exc a\n        mov b, y\n        shr b, 5\n        add a, b\n        mov d, a     # Compute return row and column\n\n    post:\n       popf\n       pop a\n       pop b\n       ret\n    }\n}\n')))}d.isMDXComponent=!0;
},{"react":"SAdv","@mdx-js/react":"QaRW"}]},{},[], null)
//# sourceMappingURL=/subroutine-calling-convention.95d5f25e.js.map
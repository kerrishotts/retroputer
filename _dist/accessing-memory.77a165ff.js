parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"UCMq":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=d;var e=a(require("react")),t=require("@mdx-js/react");function a(e){return e&&e.__esModule?e:{default:e}}function n(){return(n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}const o=e=>(function(a){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,t.mdx)("div",a)}),i={},r="wrapper";function d({components:e,...a}){return(0,t.mdx)(r,n({},i,a,{components:e,mdxType:"MDXLayout"}),(0,t.mdx)("h1",null,"Accessing Memory"),(0,t.mdx)("p",null,"Reading from and writing to memory is accomplished using the ",(0,t.mdx)("inlineCode",{parentName:"p"},"LD")," ","(","LOAD",")"," and ",(0,t.mdx)("inlineCode",{parentName:"p"},"ST")," ","(","STORE",")"," instructions respectively. These are the only two instructions that can read from and modify memory. All other instructions deal either with registers or with I/O ports."),(0,t.mdx)("h2",null,"Loading a Constant"),(0,t.mdx)("p",null,"When one needs to load a register with a specific value, but doesn't want to assign the value a location in memory, the immediate form of ",(0,t.mdx)("inlineCode",{parentName:"p"},"LD")," can be used. Technically it's very similar to any other method of loading data from memory into a register, just that the data is encoded within the instruction itself."),(0,t.mdx)("p",null,"Let's say we wanted to change the value of ",(0,t.mdx)("inlineCode",{parentName:"p"},"A")," to the value of ",(0,t.mdx)("inlineCode",{parentName:"p"},"0x1234"),". We can use the following instruction:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"ld a, 0x1234\n")),(0,t.mdx)("blockquote",null,(0,t.mdx)("h3",{parentName:"blockquote"},"NOTE"),(0,t.mdx)("p",{parentName:"blockquote"},"The assembler allows expressions too! So you could use ",(0,t.mdx)("inlineCode",{parentName:"p"},"ld a, 0x1200 + 0x34")," to accomplish the same result.")),(0,t.mdx)("h2",null,"Loading a Value from a Variable"),(0,t.mdx)("p",null,"Typically programs will store information in a variable and will need to retrieve that information later. Variables are allocated a specific amount of memory in a segment based upon the size and width of the data itself. For example, a byte takes up one byte in a segment, whereas an array of 256 words will take up 512 bytes."),(0,t.mdx)("p",null,"Assuming the variable in question is a byte or word variable, it's easy to load data from it into a register using the ",(0,t.mdx)("strong",{parentName:"p"},"absolute addressing mode"),"."),(0,t.mdx)("p",null,"First, let's imagine the following data segment -- it has one variable defined named ",(0,t.mdx)("inlineCode",{parentName:"p"},"lives")," -- this represents the number of lives a player has left in a game."),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment data 0x03000 {\n  lives: .byte 0x03\n}\n")),(0,t.mdx)("p",null,"Next, we might want to access the variable in order to see if the game is truly over. We use ",(0,t.mdx)("strong",{parentName:"p"},"absolute addressing mode")," to accomplish this. Absolute addresses are simply 19-bit numbers that refer to a specific memory address. 19 bits is sufficient to address the entirety of Retroputer's memory space. Because the address isn't relative to anything else ","(","other than ",(0,t.mdx)("inlineCode",{parentName:"p"},"0"),")",", the addressing mode is called ",(0,t.mdx)("strong",{parentName:"p"},"absolute"),"."),(0,t.mdx)("p",null,"To indicate that you're using ",(0,t.mdx)("strong",{parentName:"p"},"absolute addressing"),", one uses square brackets in the ",(0,t.mdx)("inlineCode",{parentName:"p"},"LD")," statement, like so:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\n  ld al, [data.lives]\n}\n")),(0,t.mdx)("blockquote",null,(0,t.mdx)("h3",{parentName:"blockquote"},"IMPORTANT: Register Width Matters!"),(0,t.mdx)("p",{parentName:"blockquote"},"It's critical to match the register and the width of the data you're trying to access. ",(0,t.mdx)("inlineCode",{parentName:"p"},"ld a, [0x00000]")," will load the bytes at addresses ",(0,t.mdx)("inlineCode",{parentName:"p"},"0x00000")," and ",(0,t.mdx)("inlineCode",{parentName:"p"},"0x00001")," and deposit them into the high and low bytes of ",(0,t.mdx)("inlineCode",{parentName:"p"},"A")," respectively. ",(0,t.mdx)("inlineCode",{parentName:"p"},"ld al, [0x00000]"),", however will load only the byte at address ",(0,t.mdx)("inlineCode",{parentName:"p"},"0x00000")," and deposit it into the low byte of ",(0,t.mdx)("inlineCode",{parentName:"p"},"A")," ","(","known as ",(0,t.mdx)("inlineCode",{parentName:"p"},"AL"),")",".")),(0,t.mdx)("p",null,"The above statement will actually be turned into ",(0,t.mdx)("inlineCode",{parentName:"p"},"ld al, [0x03000]")," by the assembler -- it will keep track of the fact that ",(0,t.mdx)("inlineCode",{parentName:"p"},"data.lives")," actually points to address ",(0,t.mdx)("inlineCode",{parentName:"p"},"0x03000")," for us."),(0,t.mdx)("h2",null,"Storing Data into a Variable"),(0,t.mdx)("p",null,"Storing data into a variable works similarly to how you load data from a variable. The order of operands is swapped around to indicate that the ",(0,t.mdx)("em",{parentName:"p"},"source")," and ",(0,t.mdx)("em",{parentName:"p"},"target")," is different, however."),(0,t.mdx)("p",null,"Let's say we wanted to decrement the number of lives remaining and store that back into the variable we've already defined. We can do that like so:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"dec al\nst [data.lives], al\n")),(0,t.mdx)("p",null,"This will write the new value in ",(0,t.mdx)("inlineCode",{parentName:"p"},"AL")," to memory address ",(0,t.mdx)("inlineCode",{parentName:"p"},"0x03000")," which happens to be the variable ",(0,t.mdx)("inlineCode",{parentName:"p"},"lives"),"."),(0,t.mdx)("blockquote",null,(0,t.mdx)("h3",{parentName:"blockquote"},"IMPORTANT: Register Width Matters!"),(0,t.mdx)("p",{parentName:"blockquote"},"Just like the ",(0,t.mdx)("inlineCode",{parentName:"p"},"LD")," statement, the size of the register you're using with ",(0,t.mdx)("inlineCode",{parentName:"p"},"ST")," matters. If you want to write a single byte to memory, be sure to use a single-byte register. If you want to write two bytes at once, use a word-sized register. If you fail to use the correct width, you could inadvertently overwrite memory that you didn't intend to change.")),(0,t.mdx)("h2",null,"Loading Data from an Array"))}d.isMDXComponent=!0;
},{"react":"SAdv","@mdx-js/react":"QaRW"}]},{},[], null)
//# sourceMappingURL=/accessing-memory.77a165ff.js.map
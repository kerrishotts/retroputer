parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"qb5n":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=d;var e=a(require("react")),t=require("@mdx-js/react");function a(e){return e&&e.__esModule?e:{default:e}}function n(){return(n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}const l=e=>(function(a){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,t.mdx)("div",a)}),m={},r="wrapper";function d({components:e,...a}){return(0,t.mdx)(r,n({},m,a,{components:e,mdxType:"MDXLayout"}),(0,t.mdx)("h1",null,"Instructions"),(0,t.mdx)("blockquote",null,(0,t.mdx)("h3",{parentName:"blockquote"},"Instruction Set Encodings"),(0,t.mdx)("p",{parentName:"blockquote"},"If you want to see the entire instruction set and how it is encoded, ",(0,t.mdx)("a",n({parentName:"p"},{href:"https://docs.google.com/spreadsheets/d/e/2PACX-1vSIMH-L17-UxNa2rhyLNF6gWUWPXic_-txike9oHIXu6zykN89dUTzA0-zNfKN-6toSEn6ox084nnId/pubhtml"}),"take a look at this reference"),".")),(0,t.mdx)("h2",null,"ADD ","(","with Carry",")"),(0,t.mdx)("p",null,"Adds the source to the destination and stores the result in the destination register using the following algorithm ","(","here, ",(0,t.mdx)("inlineCode",{parentName:"p"},"C")," denotes the carry flag",")","."),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"r = carry_in + source + dest_in\nsign_source = source[msb]\nsign_dest = dest[msb]\ndest_out = r[msb:0]\n")),(0,t.mdx)("p",null,"Once the result of the operation is computed, the ALU computes the flags as follows:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"z_out = {\n    1 when r = 0\n    0 when r != 0\n}\n\nc_out = {\n    0 when r>>width = 0\n    1 when r>>width >= 0\n}\n\nn_out = r[msb]\n\nv_out = {\n    0 when sign_dest = 0, sign_source = 0, and n_out = 0\n    1 when sign_dest = 0, sign_source = 0, and n_out = 1\n    0 when sign_dest = 0, sign_source = 1, and n_out = 0\n    0 when sign_dest = 0, sign_source = 1, and n_out = 1\n    0 when sign_dest = 1, sign_source = 0, and n_out = 0\n    0 when sign_dest = 1, sign_source = 0, and n_out = 1\n    1 when sign_dest = 1, sign_source = 1, and n_out = 0\n    0 when sign_dest = 1, sign_source = 1, and n_out = 1\n}    \n")),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Warning")),(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("inlineCode",{parentName:"p"},"ADD")," always takes the carry flag in to account when performing addition. As such, you should always ",(0,t.mdx)("inlineCode",{parentName:"p"},"CLR C")," before any addition when you know that the carry flag should not be considered.")),(0,t.mdx)("h4",null,"Forms"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Destination"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Source"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Addressable Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Addressable Register")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Data Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Immediate 8-bit value")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Data Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Immediate 16-bit value")))),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"ADD dest, src\nADD dest, immediate\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\n    ld a, 1234\n    add a, 2345       # a is 3579\n\n    ld a, 0x5000\n    ld b, 0x4000\n    add a, b          # value in a is incorrect if this is signed\n                      # addition -- V is set. For unsigned addition\n                      # a is 0x9000.\n}\n")),(0,t.mdx)("h2",null,"AND ","(","Bitwise AND",")"),(0,t.mdx)("p",null,"Performs a bitwise AND on the source and destination operands, and stores the result in the destination."),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"r = dest_out = dest_in AND source_in\n")),(0,t.mdx)("p",null,"Once the result of the operation is computed, the ALU computes the flags as follows:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"z_out = {\n    1 when r = 0\n    0 when r != 0\n}\n\nc_out = 0\n\nn_out = r[msb]\n\nv_out = 0\n")),(0,t.mdx)("h4",null,"Forms"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Destination"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Source"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Addressable Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Addressable Register")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Data Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Immediate 8-bit value")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Data Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Immediate 16-bit value")))),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"0"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"AND dest, src\nAND dest, immediate\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\n    ld al, 0b1111_0000\n    and al, 0b0001_1000    # al is 0b0001_0000\n\n    ld a, 0x1234\n    ld b, 0x00FF\n    and a, b               # a is 0x0034\n}\n")),(0,t.mdx)("h2",null,"BR ","(","Branch",")"),(0,t.mdx)("p",null,"Sets ",(0,t.mdx)("inlineCode",{parentName:"p"},"PC")," to the specified value, causing a jump or branch to that location. Code execution continues from the new address. The width of the value determines if the branch is ",(0,t.mdx)("em",{parentName:"p"},"short")," ","(","8 bits",")"," or ",(0,t.mdx)("em",{parentName:"p"},"long")," ","(","16 bits",")","."),(0,t.mdx)("p",null,"Branches can be unconditional ","(","the branch is taken every time",")",", or they can be conditional ","(","based upon if a flag is set or not",")","."),(0,t.mdx)("h4",null,"Forms"),(0,t.mdx)("p",null,"A branch is ",(0,t.mdx)("em",{parentName:"p"},"long")," unless ",(0,t.mdx)("inlineCode",{parentName:"p"},"s")," is added to the alias. That is, ",(0,t.mdx)("inlineCode",{parentName:"p"},"br")," is a long branch, whereas ",(0,t.mdx)("inlineCode",{parentName:"p"},"brs")," is a short branch."),(0,t.mdx)("p",null,"The unconditional form specifies only a target address:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"br next-frame        # long branch\n")),(0,t.mdx)("p",null,"The conditional form specifies a target address ",(0,t.mdx)("em",{parentName:"p"},"and")," a flag. If the flag is set, the branch will be taken. Conditionals can also be ",(0,t.mdx)("em",{parentName:"p"},"negated"),", meaning that the branch will be taken if the flag is clear."),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"brs z next-frame        # branch to next-frame if last ALU op was zero\nbr !c end-game          # branch to end-game if carry is clear\n")),(0,t.mdx)("p",null,"It should be noted that there are no concessions offered for checking multiple flags at once -- such as you might want to do when checking if a value is less than or equal to another value. Instead, you must make multiple branches:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"ld a, 0x4000\ncmp a, 0x4001\nbr z lte        # when zero is set, that signals equality\nbr n lte        # when negative is set, that signals less-than\n")),(0,t.mdx)("p",null,"For reference, the following conditions may prove useful when mapping flags to their mathematical equivalents:"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Result of Comparison"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Flags"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Equal"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Z")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Not Equal"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"!Z")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Less Than"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"N")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Greater Than"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"C")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Less Than or Equal"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Z, N")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Greater Than or Equal"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Z, C")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"BR[S] [!][flag]\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment data 0x03000 {\n     lives: .byte 3\n}\n.segment code 0x02000 {\n     ld al, [lives]\n     cmp al, 0\n     br z game-over\n     # more code\ngame-over:\n     # no more lives left!\n     brk\n}\n")),(0,t.mdx)("h2",null,(0,t.mdx)("strong",{parentName:"h2"},"BRK ","(","Break",")")),(0,t.mdx)("p",null,"Transitions the CPU to single-step mode. This will cause the debugger to halt the processor until a single-step or continue signal is received."),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"+"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"+"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"BRK\n")),(0,t.mdx)("h2",null,"CALL ","(","Subroutine",")"),(0,t.mdx)("p",null,"Pushes ",(0,t.mdx)("inlineCode",{parentName:"p"},"PC")," on to the stack, and then sets ",(0,t.mdx)("inlineCode",{parentName:"p"},"PC")," to the specified value, causing a jump or branch to that location. Code execution continues from the new address. The width of the value determines if the branch is ",(0,t.mdx)("em",{parentName:"p"},"short")," ","(","8 bits",")"," or ",(0,t.mdx)("em",{parentName:"p"},"long")," ","(","16 bits",")","."),(0,t.mdx)("p",null,"Calls can be unconditional ","(","the branch is taken every time",")",", or they can be conditional ","(","based upon if a flag is set or not",")","."),(0,t.mdx)("h4",null,"Forms"),(0,t.mdx)("p",null,"A call is ",(0,t.mdx)("em",{parentName:"p"},"long")," unless ",(0,t.mdx)("inlineCode",{parentName:"p"},"s")," is added to the alias. That is, ",(0,t.mdx)("inlineCode",{parentName:"p"},"call")," is a long call, whereas ",(0,t.mdx)("inlineCode",{parentName:"p"},"calls")," is a short call."),(0,t.mdx)("p",null,"The unconditional form specifies only a target address:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"call next-frame        # long call\n")),(0,t.mdx)("p",null,"The conditional form specifies a target address ",(0,t.mdx)("em",{parentName:"p"},"and")," a flag. If the flag is set, the call will be taken. Conditionals can also be ",(0,t.mdx)("em",{parentName:"p"},"negated"),", meaning that the call will be taken if the flag is clear."),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"calls z next-frame        # call next-frame if last ALU op was zero\ncall !c end-game          # call end-game if carry is clear\n")),(0,t.mdx)("p",null,"It should be noted that there are no concessions offered for checking multiple flags at once -- such as you might want to do when checking if a value is less than or equal to another value. Instead, you should make multiple branches and then call :"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"ld a, 0x4000\ncmp a, 0x4001\nbr z _lte        # when zero is set, that signals equality\nbr n _lte        # when negative is set, that signals less-than\nbrk\n_lte:\ncall lte         # call lte if less than or equal\n")),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"CALL[S] [!][flag]\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment data 0x03000 {\n     score: .word 0\n}\n.segment code 0x02000 {\n     ld a, [score]\n     cmp a, 10000\n     call z extra-life\n     # more code\n     brk\nextra-life:\n     # bonus life!\n     ld a, [score]\n     inc a\n     st [score], a\n     ret\n}\n")),(0,t.mdx)("h2",null,(0,t.mdx)("strong",{parentName:"h2"},"CLR ","(","Clear Flag",")")),(0,t.mdx)("p",null,"Clears the specified flag."),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"CLR flag\n")),(0,t.mdx)("h4",null,"Example"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"clr c        # clear the carry flag before addition\nadd a, b\n")),(0,t.mdx)("h2",null,"CMP ","(","Compare",")"),(0,t.mdx)("p",null,"Compares the two values and sets the flags according to the results of the comparison."),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"r = dest_in - source\nsign_source = source[msb]\nsign_dest = dest_in[msb]\n")),(0,t.mdx)("p",null,"Once the result of the operation is computed, the ALU computes the flags as follows:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"z_out = {\n    1 when r = 0\n    0 when r != 0\n}\n\nc_out = {\n    0 when r>>width = 0\n    1 when r>>width >= 0\n}\n\nn_out = r[msb]\n\nv_out = {\n    0 when sign_dest = 0, sign_source = 1, and n_out = 0\n    1 when sign_dest = 0, sign_source = 1, and n_out = 1\n    0 when sign_dest = 0, sign_source = 0, and n_out = 0\n    0 when sign_dest = 0, sign_source = 0, and n_out = 1\n    0 when sign_dest = 1, sign_source = 1, and n_out = 0\n    0 when sign_dest = 1, sign_source = 1, and n_out = 1\n    1 when sign_dest = 1, sign_source = 0, and n_out = 0\n    0 when sign_dest = 1, sign_source = 0, and n_out = 1\n}   \n")),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Note")),(0,t.mdx)("p",{parentName:"blockquote"},"Unlike other arithmetic operations, ",(0,t.mdx)("inlineCode",{parentName:"p"},"cmp")," does not take the carry flag into consideration when performing a comparison.")),(0,t.mdx)("h4",null,"Forms"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Destination"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Source"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Addressable Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Addressable Register")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Data Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Immediate 8-bit value")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Data Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Immediate 16-bit value")))),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓")))),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Note")),(0,t.mdx)("p",{parentName:"blockquote"},"Although the full contingent of ALU flags is calculated when ",(0,t.mdx)("inlineCode",{parentName:"p"},"cmp")," is executed, only ",(0,t.mdx)("inlineCode",{parentName:"p"},"N")," , ",(0,t.mdx)("inlineCode",{parentName:"p"},"C"),", and",(0,t.mdx)("inlineCode",{parentName:"p"},"Z")," have any real meaning.")),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Meaning"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Set"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Source and Destination are equal")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Clear"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Source and Destination are unequal")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Set"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Destination is less than Source")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Set"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Destination is greater than Source")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"CMP dest, src\nCMP dest, immediate\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\n    ld a, 0x2000\n    ld b, 0x2001\n    cmp a, b          # N will be set because a < b\n                      # Z will be clear (not equal)\n}\n")),(0,t.mdx)("h2",null,"DEC ","(","Decrement",")"),(0,t.mdx)("p",null,"Decrements the specified register by one, updating flags as appropriate:"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Condition"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Flag"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Result is zero"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Z is set")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Result is negative"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"N is set")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Result goes below zero"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"C is set")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Result goes below signed minimum"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"V is set")))),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Note")),(0,t.mdx)("p",{parentName:"blockquote"},"Unlike other arithmetic operations, ",(0,t.mdx)("inlineCode",{parentName:"p"},"dec")," does not take the carry flag into consideration when performing a comparison.")),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"DEC dest\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\n    ld a, 0x2000\n    dec a\n}\n")),(0,t.mdx)("h2",null,"DIV ","(","Unsigned Divide",")"),(0,t.mdx)("p",null,"Divides the destination by the source, and stores the result in the destination."),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"r = source / dest_in\ndest_out = r[msb:0]\n")),(0,t.mdx)("p",null,"Once the result of the operation is computed, the ALU computes the flags as follows:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"z_out = {\n    1 when r = 0\n    0 when r != 0\n}\n\nc_out = 0\n\nn_out = r[msb]\n\nv_out = 0\n\nEX_out = {\n    1 when dest_in = 0\n    EX_in when dest_in != 0\n}\n\n")),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Note")),(0,t.mdx)("p",{parentName:"blockquote"},"If the operation would result in a division by zero, the ",(0,t.mdx)("inlineCode",{parentName:"p"},"EX")," flag will be set, indicating a processor exception. This flag is not cleared automatically—it must be cleared using ",(0,t.mdx)("inlineCode",{parentName:"p"},"clr ex")," manually."),(0,t.mdx)("p",{parentName:"blockquote"},"The ",(0,t.mdx)("inlineCode",{parentName:"p"},"C"),", ",(0,t.mdx)("inlineCode",{parentName:"p"},"N"),", ",(0,t.mdx)("inlineCode",{parentName:"p"},"Z"),", and ",(0,t.mdx)("inlineCode",{parentName:"p"},"V")," flags are also set. The return result will be ",(0,t.mdx)("inlineCode",{parentName:"p"},"0"),".")),(0,t.mdx)("h4",null,"Forms"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Destination"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Source"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Addressable Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Addressable Register")))),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"DIV dest, src\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\n    ld a, 2000\n    ld b, 20\n    div a, b          # a is 100\n\n    ld a, 0x5000\n    ld b, 0\n    div a, b          # a is zero, and EX is set (divide by zero)\n}\n")),(0,t.mdx)("h2",null,"ENTER ","(","Enter Stack Frame",")"),(0,t.mdx)("p",null,"Allocates the specified number of bytes on the stack and adjusts ",(0,t.mdx)("inlineCode",{parentName:"p"},"SP")," and ",(0,t.mdx)("inlineCode",{parentName:"p"},"BP")," to create a new stack frame."),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Note")),(0,t.mdx)("p",{parentName:"blockquote"},"The data allocated on the stack is ",(0,t.mdx)("em",{parentName:"p"},"not zeroed"),". You should initialize it with data before use.")),(0,t.mdx)("p",null,"Specifically, the order of operations is as follows:"),(0,t.mdx)("ul",null,(0,t.mdx)("li",{parentName:"ul"},(0,t.mdx)("inlineCode",{parentName:"li"},"BP")," is pushed on to the stack"),(0,t.mdx)("li",{parentName:"ul"},(0,t.mdx)("inlineCode",{parentName:"li"},"SP")," is moved to ",(0,t.mdx)("inlineCode",{parentName:"li"},"BP")),(0,t.mdx)("li",{parentName:"ul"},(0,t.mdx)("inlineCode",{parentName:"li"},"SP")," is decremented by the specified number of bytes")),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Warning")),(0,t.mdx)("p",{parentName:"blockquote"},"Be sure there is sufficient space on the stack before using ",(0,t.mdx)("inlineCode",{parentName:"p"},"ENTER"),", otherwise a stack overflow could occur and memory outside of the stack could be overwritten.")),(0,t.mdx)("p",null,"In order to access the reserved data on the stack, one should use ",(0,t.mdx)("inlineCode",{parentName:"p"},"BP"),"-relative addressing:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"enter 2\nld a, [BP+0]        # Previous BP\nld a, [BP+-2]       # Reserved word on stack\n")),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"ENTER immediate\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\nmain:\n    enter 10           # reserve space on the stack for 10 bytes\n    ...\n    exit 10\n    ret\n}\n")),(0,t.mdx)("h2",null,"EXC ","(","Exchange Components",")"),(0,t.mdx)("p",null,"Exchanges the components of the register. Used to access the high portions of a 16-bit register, but also works to swap nybbles in an 8-bit register. Flags are updated as a result, although only ",(0,t.mdx)("inlineCode",{parentName:"p"},"N")," and ",(0,t.mdx)("inlineCode",{parentName:"p"},"Z")," have any real meaning."),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"EXC register\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\n    ld a, 0x3134\n    out 0x80, al      # output 34 to port 80\n    exc a             # exchange the high and low components\n                      # a is now 0x3431\n    out 0x80, al      # output 31 to port 80\n    exc a             # restore a to the original value\n}\n")),(0,t.mdx)("h2",null,"EXIT ","(","Exit Stack Frame",")"),(0,t.mdx)("p",null,"Exits from the current stack frame, deallocating the specified number of bytes."),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Warning")),(0,t.mdx)("p",{parentName:"blockquote"},"The number of bytes to deallocate ",(0,t.mdx)("em",{parentName:"p"},"must")," match the number of bytes allocated by the corresponding ",(0,t.mdx)("inlineCode",{parentName:"p"},"ENTER")," instruction. Otherwise the stack will become corrupted.")),(0,t.mdx)("p",null,"Specifically, the order of operations is as follows:"),(0,t.mdx)("ul",null,(0,t.mdx)("li",{parentName:"ul"},(0,t.mdx)("inlineCode",{parentName:"li"},"SP")," is incremented by the specified number of bytes"),(0,t.mdx)("li",{parentName:"ul"},"The next word on the stack ","(","previous ",(0,t.mdx)("inlineCode",{parentName:"li"},"BP"),")"," is popped into ",(0,t.mdx)("inlineCode",{parentName:"li"},"BP"))),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Warning")),(0,t.mdx)("p",{parentName:"blockquote"},"Be sure there is a stack frame on the stack before using ",(0,t.mdx)("inlineCode",{parentName:"p"},"EXIT"),", otherwise a stack underflow could occur and memory outside of the stack could be overwritten.")),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"EXIT immediate\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\nmain:\n    enter 10           # reserve space on the stack for 10 bytes\n    ...\n    exit 10            # always make sure the immediate value matches!\n    ret\n}\n")),(0,t.mdx)("h2",null,"IN ","(","Input from port",")"),(0,t.mdx)("p",null,"Inputs a byte from a given port into the specified register. The size of the register doesn't matter—the low eight bits of the register will contain the value from the port."),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"IN dest, port#\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\nmain:\n    in al, 0x80\n}\n")),(0,t.mdx)("h2",null,"INC ","(","Increment",")"),(0,t.mdx)("p",null,"Increment the specified register by one, updating flags as appropriate:"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Condition"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Flag"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Result is zero"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Z is set")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Result is negative"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"N is set")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Result goes above unsigned maximum"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"C is set")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Result goes below signed maximum"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"V is set")))),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Note")),(0,t.mdx)("p",{parentName:"blockquote"},"Unlike other arithmetic operations, ",(0,t.mdx)("inlineCode",{parentName:"p"},"inc")," does not take the carry flag into consideration when performing a comparison.")),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"INC dest\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\n    ld a, 0x2000\n    inc a\n}\n")),(0,t.mdx)("h2",null,"LD ","(","Load Data",")"),(0,t.mdx)("p",null,"Loads data from memory ","(","or immediately from the instruction",")"," into a destination register. The width of the destination determines how much data is loaded—if the destination is an eight-bit register, only one byte will be loaded, and if is a sixteen-bit register, two bytes will be loaded. Note that data is always stored and loaded in ",(0,t.mdx)("em",{parentName:"p"},"big endian"),"."),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Note")),(0,t.mdx)("p",{parentName:"blockquote"},"Loading data into a register does not affect the processor status flags.")),(0,t.mdx)("p",null,"The immediate forms of this instruction allows direct assignment of a value to a register:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"LD A, 1234\nLD AL, 65\n")),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Warning")),(0,t.mdx)("p",{parentName:"blockquote"},"When loading data into the low portion of the register, the data in the high portion is not modified.")),(0,t.mdx)("p",null,"The other forms load data from memory into the destination register. There are several ",(0,t.mdx)("a",n({parentName:"p"},{href:"../../technical/technical-overview/6516-central-processing-unit/addressing-modes.md"}),"addressing modes")," available."),(0,t.mdx)("h2",null,"LOOP"),(0,t.mdx)("p",null,"Decrements the target register, and then if carry hasn't been set, loops back to the target address. The width of the value determines if the loop is ",(0,t.mdx)("em",{parentName:"p"},"short")," ","(","8 bits",")"," or ",(0,t.mdx)("em",{parentName:"p"},"long")," ","(","16 bits",")","."),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Note")),(0,t.mdx)("p",{parentName:"blockquote"},"The body of the loop will always be taken at least once. Initialize the starting value of your loop register accordingly."),(0,t.mdx)("pre",{parentName:"blockquote"},(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"    ld c, 0\n_loop:\n    out 0x80, cl      # executes once\n    loop _loop, c\n"))),(0,t.mdx)("h4",null,"Forms"),(0,t.mdx)("p",null,"A loop is ",(0,t.mdx)("em",{parentName:"p"},"long")," unless ",(0,t.mdx)("inlineCode",{parentName:"p"},"s")," is added to the alias. That is, ",(0,t.mdx)("inlineCode",{parentName:"p"},"loop")," is a long loop, whereas ",(0,t.mdx)("inlineCode",{parentName:"p"},"loops")," is a short loop."),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"loops c next-frame        # short loop to next-frame\nloop c next-game          # long loop to next-frame\n")),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"LOOP[S] target-address, loop-register\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"todo\n")),(0,t.mdx)("h2",null,"MOD ","(","Unsigned Modulo",")"),(0,t.mdx)("p",null,"Divides the destination by the source, and stores the remainder in the destination."),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"r = source mod dest_in\ndest_out = r[msb:0]\n")),(0,t.mdx)("p",null,"Once the result of the operation is computed, the ALU computes the flags as follows:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"z_out = {\n    1 when r = 0\n    0 when r != 0\n}\n\nc_out = 0\n\nn_out = r[msb]\n\nv_out = 0\n\nEX_out = {\n    1 when dest_in = 0\n    EX_in when dest_in != 0\n}\n")),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Note")),(0,t.mdx)("p",{parentName:"blockquote"},"If the operation would result in a division by zero, the ",(0,t.mdx)("inlineCode",{parentName:"p"},"EX")," flag will be set, indicating a processor exception. This flag is not cleared automatically—it must be cleared using ",(0,t.mdx)("inlineCode",{parentName:"p"},"clr ex")," manually."),(0,t.mdx)("p",{parentName:"blockquote"},"The ",(0,t.mdx)("inlineCode",{parentName:"p"},"C"),", ",(0,t.mdx)("inlineCode",{parentName:"p"},"N"),", ",(0,t.mdx)("inlineCode",{parentName:"p"},"Z"),", and ",(0,t.mdx)("inlineCode",{parentName:"p"},"V")," flags are also set. The return result will be ",(0,t.mdx)("inlineCode",{parentName:"p"},"0"),".")),(0,t.mdx)("h4",null,"Forms"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Destination"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Source"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Addressable Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Addressable Register")))),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"MOD dest, src\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\n    ld a, 2000\n    ld b, 20\n    mod a, b          # a is 0\n\n    ld a, 0x5000\n    ld b, 0\n    mod a, b          # a is zero, and EX is set (divide by zero)\n}\n")),(0,t.mdx)("h2",null,"MOV ","(","Move",")"),(0,t.mdx)("p",null,"Transfers the value of one register into another register. Flags are not affected."),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"MOV dest, srce\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"ld a, 10\nmov b, a\nld a, 20\n")),(0,t.mdx)("h2",null,"MUL ","(","Unsigned Multiply",")"),(0,t.mdx)("p",null,"Multiples the destination by the source, and stores the result in the destination."),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"r = source * dest_in\ndest_out = r[msb:0]\n")),(0,t.mdx)("p",null,"Once the result of the operation is computed, the ALU computes the flags as follows:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"z_out = {\n    1 when r = 0\n    0 when r != 0\n}\n\nc_out = r > max-unsigned-word\n\nn_out = r[msb]\n\nv_out = 0\n")),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},(0,t.mdx)("strong",{parentName:"p"},"Note")),(0,t.mdx)("p",{parentName:"blockquote"},"If the operation would result in a value too large for the destination register, the ",(0,t.mdx)("inlineCode",{parentName:"p"},"C")," flag is set.")),(0,t.mdx)("h4",null,"Forms"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Destination"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Source"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Addressable Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Addressable Register")))),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"MUL dest, src\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\n    ld a, 2000\n    ld b, 2\n    mul a, b          # a is 4000\n\n    ld a, 0x5000\n    ld b, 0\n    mul a, b          # a is zero\n}\n")),(0,t.mdx)("h2",null,"NEG ","(","Negate",")"),(0,t.mdx)("p",null,"Negates ","(","two's complement",")"," the signed value in the register. If the register was originally ",(0,t.mdx)("inlineCode",{parentName:"p"},"42"),", it will now be ",(0,t.mdx)("inlineCode",{parentName:"p"},"-42"),"."),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"NEG dest\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\n    ld a, 2000\n    neg a        # a is -2000\n}\n")),(0,t.mdx)("h2",null,"NOP ","(","No Operation",")"),(0,t.mdx)("p",null,"Do nothing. Takes some time, so can be used to slow a process down slightly."),(0,t.mdx)("h2",null,"NOT ","(","Bitwise Not",")"),(0,t.mdx)("p",null,"Flips the bits in the register. If the register was originally ",(0,t.mdx)("inlineCode",{parentName:"p"},"0b10010010"),", it will now be ",(0,t.mdx)("inlineCode",{parentName:"p"},"0b01101101"),"."),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"dest-out = !dest_in\n")),(0,t.mdx)("p",null,"Flags are computed as follows:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"z_out = {\n    1 when r = 0\n    0 when r != 0\n}\n\nc_out = 0\nn_out = r[msb]\nv_out = 0\n")),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"NOT dest\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\n    ld al, 0b0000_1111\n    not al        # a is 0b1111_0000 or 0xF0\n}\n")),(0,t.mdx)("h2",null,"OR ","(","Bitwise Or",")"),(0,t.mdx)("p",null,"Performs a bitwise OR on the source and destination operands, and stores the result in the destination."),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"dest_out = dest_in OR source_in\n")),(0,t.mdx)("p",null,"Once the result of the operation is computed, the ALU computes the flags as follows:"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"z_out = {\n    1 when r = 0\n    0 when r != 0\n}\n\nc_out = {\n    0 when r >> width = 0\n    1 when r >> width >= 0\n}\n\nn_out = r[msb]\n\nv_out = 0\n")),(0,t.mdx)("h4",null,"Forms"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Destination"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Source"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Addressable Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Addressable Register")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Data Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Immediate 8-bit value")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Data Register"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"Immediate 16-bit value")))),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"-"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"0"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"OR dest, src\nOR dest, immediate\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\n    ld al, 0b1111_0000\n    or al, 0b0001_1000    # al is 0b1111_1000\n\n    ld a, 0x1234\n    ld b, 0x00FF\n    or a, b               # a is 0x12FF\n}\n")),(0,t.mdx)("h2",null,"OUT ","(","Output to port",")"),(0,t.mdx)("p",null,"Outputs a byte to a given port from the specified register. The size of the register doesn't matter—the low eight bits of the register will be sent to the port."),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"OUT port#, srce\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\nmain:\n    out 0x80, al\n}\n")),(0,t.mdx)("h2",null,"POP ","(","Pop from Stack",")"),(0,t.mdx)("p",null,"Pops the top value from the stack and stores it in the specified register. The width of the register determines if a byte or a word is popped from the stack."),(0,t.mdx)("p",null,(0,t.mdx)("inlineCode",{parentName:"p"},"SP")," is increased by the size of the data popped from the stack."),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"POP dest\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\nmain:\n    pop a\n}\n")),(0,t.mdx)("h2",null,"POPALL"),(0,t.mdx)("p",null,"Pops the state of the addressable registers from the stack, in reverse order as ",(0,t.mdx)("inlineCode",{parentName:"p"},"PUSHALL"),"."),(0,t.mdx)("ul",null,(0,t.mdx)("li",{parentName:"ul"},"BP"),(0,t.mdx)("li",{parentName:"ul"},"Y"),(0,t.mdx)("li",{parentName:"ul"},"X"),(0,t.mdx)("li",{parentName:"ul"},"D"),(0,t.mdx)("li",{parentName:"ul"},"C"),(0,t.mdx)("li",{parentName:"ul"},"B"),(0,t.mdx)("li",{parentName:"ul"},"A"),(0,t.mdx)("li",{parentName:"ul"},"SP")),(0,t.mdx)("p",null,"Unless you need to store all the above registers on the stack, it's better to push and pop only those registers that you need, as the ",(0,t.mdx)("inlineCode",{parentName:"p"},"POPALL")," command is very slow."),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"POPALL\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\nmain:\n    pushall\n    # some intermediate code\n    popall\n    ret\n}\n")),(0,t.mdx)("h2",null,"POPF ","(","Pop Flags",")"),(0,t.mdx)("p",null,"Pops the top byte off the stack and sets the processor status flags to the value popped."),(0,t.mdx)("h4",null,"Flags"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"EX"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"ID"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"IS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"SS"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"N"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"C"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"V"),(0,t.mdx)("th",n({parentName:"tr"},{align:"left"}),"Z"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓"),(0,t.mdx)("td",n({parentName:"tr"},{align:"left"}),"✓")))),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"POPF\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\nmain:\n    ld al, 1\n    push al\n    popf        # z is now set\n}\n")),(0,t.mdx)("h2",null,"POPMM ","(","Pop Memory Map",")"),(0,t.mdx)("p",null,"Pops the top value on the stack and sets the memory map register to that value. Used to finish a page map operation."),(0,t.mdx)("h4",null,"Grammar"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),"POPMM\n")),(0,t.mdx)("h4",null,"Examples"),(0,t.mdx)("pre",null,(0,t.mdx)("code",n({parentName:"pre"},{className:"language-text"}),".segment code 0x02000 {\nmain:\n    set id      # disable interrupts\n    pushmm      # save the current memory map\n    pop a       # pop it into A\n    and a, 0b0_11111_00000_11111   # zero page 2 mapping\n    or a, 0b0_00000_00100_00000    # set page 2 to map to page 4\n    push a\n    pop mm      # pop revised memory map\n    clr id      # re-enable interrupts\n}\n")),(0,t.mdx)("h2",null,"PUSH"),(0,t.mdx)("h2",null,"PUSHALL"),(0,t.mdx)("h2",null,"PUSHF ","(","Push Flags",")"),(0,t.mdx)("h2",null,"PUSHMM ","(","Push Memory Map",")"),(0,t.mdx)("h2",null,"RET ","(","Return from Call",")"),(0,t.mdx)("h2",null,"SDIV ","(","Signed Divide",")"),(0,t.mdx)("h2",null,"SHL ","(","Shift Left",")"),(0,t.mdx)("h2",null,"SHR ","(","Shift Right",")"),(0,t.mdx)("h2",null,"SMOD ","(","Signed Modulo",")"),(0,t.mdx)("h2",null,"SMUL ","(","Signed Multiplication",")"),(0,t.mdx)("h2",null,"ST ","(","Store",")"),(0,t.mdx)("h2",null,"SUB ","(","Subtract",")"),(0,t.mdx)("h2",null,"SWAP"),(0,t.mdx)("h2",null,"TEST"),(0,t.mdx)("h2",null,"TRAP"),(0,t.mdx)("h2",null,"XOR ","(","Bitwise Exclusive OR",")"))}d.isMDXComponent=!0;
},{"react":"SAdv","@mdx-js/react":"QaRW"}]},{},[], null)
//# sourceMappingURL=/instructions.a45f7e6d.js.map
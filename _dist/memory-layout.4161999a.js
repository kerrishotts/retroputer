parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"MEdh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=m;var t=l(require("react")),e=require("@mdx-js/react");function l(t){return t&&t.__esModule?t:{default:t}}function a(){return(a=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var l=arguments[e];for(var a in l)Object.prototype.hasOwnProperty.call(l,a)&&(t[a]=l[a])}return t}).apply(this,arguments)}const n=t=>(function(l){return console.warn("Component "+t+" was not imported, exported, or provided by MDXProvider as global scope"),(0,e.mdx)("div",l)}),d={},x="wrapper";function m({components:t,...l}){return(0,e.mdx)(x,a({},d,l,{components:t,mdxType:"MDXLayout"}),(0,e.mdx)("h1",null,"Memory Layout"),(0,e.mdx)("p",null,"Retroputer has access to 512 kilobytes of memory, split up into eight banks of 64 kilobytes each. Only the first bank can contain executable code."),(0,e.mdx)("p",null,"Each bank is then split up into four pages of 16 kilobytes. The initial memory map at boot-up looks like the following:"),(0,e.mdx)("p",null,(0,e.mdx)("img",a({parentName:"p"},{src:"../../images/memory-map.png",alt:"Memory Layout at boot-up"}))),(0,e.mdx)("table",null,(0,e.mdx)("thead",null,(0,e.mdx)("tr",null,(0,e.mdx)("th",{style:"text-align:left"},"Bank"),(0,e.mdx)("th",{style:"text-align:left"},"Role"))),(0,e.mdx)("tbody",null,(0,e.mdx)("tr",null,(0,e.mdx)("td",{style:"text-align:left"},"0"),(0,e.mdx)("td",{style:"text-align:left"},(0,e.mdx)("p",null,"Trap Vectors"),(0,e.mdx)("p",null,"KERNEL Scratch and Sprite Data"),(0,e.mdx)("p",null,"System Stack"),(0,e.mdx)("p",null,"User Code"))),(0,e.mdx)("tr",null,(0,e.mdx)("td",{style:"text-align:left"},"1"),(0,e.mdx)("td",{style:"text-align:left"},"Screen Memory (by default)")),(0,e.mdx)("tr",null,(0,e.mdx)("td",{style:"text-align:left"},"2"),(0,e.mdx)("td",{style:"text-align:left"},"General Purpose Data")),(0,e.mdx)("tr",null,(0,e.mdx)("td",{style:"text-align:left"},"3"),(0,e.mdx)("td",{style:"text-align:left"},"General Purpose Data")),(0,e.mdx)("tr",null,(0,e.mdx)("td",{style:"text-align:left"},"4"),(0,e.mdx)("td",{style:"text-align:left"},"General Purpose Data")),(0,e.mdx)("tr",null,(0,e.mdx)("td",{style:"text-align:left"},"5"),(0,e.mdx)("td",{style:"text-align:left"},"General Purpose Data")),(0,e.mdx)("tr",null,(0,e.mdx)("td",{style:"text-align:left"},"6"),(0,e.mdx)("td",{style:"text-align:left"},"General Purpose Data")),(0,e.mdx)("tr",null,(0,e.mdx)("td",{style:"text-align:left"},"7"),(0,e.mdx)("td",{style:"text-align:left"},"ROM (Character, Palette, Kernel)")))),(0,e.mdx)("p",null,"Each bank is split into four pages, resulting in 32 addressable pages. Pages 28–31 are read-only ","(","being the entirety of bank 7",")",". Pages 1–3 in bank 0 can be remapped with the ",(0,e.mdx)("inlineCode",{parentName:"p"},"MM")," register. At startup, the first four pages are mapped as follows:"),(0,e.mdx)("table",null,(0,e.mdx)("thead",null,(0,e.mdx)("tr",null,(0,e.mdx)("th",{style:"text-align:left"},"Page"),(0,e.mdx)("th",{style:"text-align:left"},"Mapping"),(0,e.mdx)("th",{style:"text-align:left"},"Remappable?"),(0,e.mdx)("th",{style:"text-align:left"},"Role"))),(0,e.mdx)("tbody",null,(0,e.mdx)("tr",null,(0,e.mdx)("td",{style:"text-align:left"},"0"),(0,e.mdx)("td",{style:"text-align:left"},"0"),(0,e.mdx)("td",{style:"text-align:left"},"No"),(0,e.mdx)("td",{style:"text-align:left"},(0,e.mdx)("p",null,"Trap Vectors"),(0,e.mdx)("p",null,"Kernel Scratch and Sprite Data"),(0,e.mdx)("p",null,"Stack"),(0,e.mdx)("p",null,"User Code"))),(0,e.mdx)("tr",null,(0,e.mdx)("td",{style:"text-align:left"},"1"),(0,e.mdx)("td",{style:"text-align:left"},"1"),(0,e.mdx)("td",{style:"text-align:left"},"Yes"),(0,e.mdx)("td",{style:"text-align:left"},"User Code and Data")),(0,e.mdx)("tr",null,(0,e.mdx)("td",{style:"text-align:left"},"2"),(0,e.mdx)("td",{style:"text-align:left"},"2"),(0,e.mdx)("td",{style:"text-align:left"},"Yes"),(0,e.mdx)("td",{style:"text-align:left"},"User Code and Data")),(0,e.mdx)("tr",null,(0,e.mdx)("td",{style:"text-align:left"},"3"),(0,e.mdx)("td",{style:"text-align:left"},"31"),(0,e.mdx)("td",{style:"text-align:left"},"Yes"),(0,e.mdx)("td",{style:"text-align:left"},"KERNEL (ROM)")))),(0,e.mdx)("p",null,"Because ",(0,e.mdx)("inlineCode",{parentName:"p"},"MM")," can be modified with the ",(0,e.mdx)("inlineCode",{parentName:"p"},"PUSHMM")," instruction, it is posible to map in code and data from any page in memory. This means that it is possible, with some clever programming, to write programs with much more code than 64 kilobytes."))}m.isMDXComponent=!0;
},{"react":"SAdv","@mdx-js/react":"QaRW"}]},{},[], null)
//# sourceMappingURL=/memory-layout.4161999a.js.map
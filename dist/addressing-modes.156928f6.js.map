{"version":3,"sources":["../../../docs/technical/technical-overview/6516-central-processing-unit/addressing-modes.md"],"names":["makeShortcode","name","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":"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","file":"addressing-modes.156928f6.js","sourceRoot":"../src/www/simple","sourcesContent":["/* @jsx mdx */\nimport React from 'react';\nimport { mdx } from '@mdx-js/react'\n/* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1>{`Addressing Modes`}</h1>\n    <p>{`Without the ability to address memory, the 6516 CPU would be very limited, since it only has a few registers with which to store and process data. Addressing memory, however, is often more complicated than one might initially imagine, since one needs to be able to effectively reference data on the stack, perform array indexing operations, and also perform pointer operations.`}</p>\n    <p>{`The following addressing modes are supported by the 6516.`}</p>\n    <h2>{`Immediate `}{`(`}{`8/16`}{`)`}</h2>\n    <p>{`This mode applies only to the `}<inlineCode parentName=\"p\">{`LD`}</inlineCode>{` instruction and is used to quickly transfer constants into a register. The width of the register determines the length of the instruction required to fit the constant value.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`ld a, 1234     # four bytes required for this instruction\nld al, 65      # three bytes required for this instruction\n`}</code></pre>\n    <h2>{`Relative `}{`(`}{`8/16`}{`)`}</h2>\n    <p>{`Relative addressing is used only for instructions that affect the program's control flow, namely `}<inlineCode parentName=\"p\">{`BR`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`CALL`}</inlineCode>{`, and `}<inlineCode parentName=\"p\">{`LOOP`}</inlineCode>{` `}{`(`}{`and short variants`}{`)`}{`. The address is relative to the `}<em parentName=\"p\">{`next`}</em>{` instruction.`}</p>\n    <blockquote>\n      <h4 parentName=\"blockquote\"><strong parentName=\"h4\">{`Note`}</strong></h4>\n      <p parentName=\"blockquote\">{`PC will be pointing at the next instruction, so a `}<inlineCode parentName=\"p\">{`BR -4`}</inlineCode>{` will enter an infinite loop. `}{`(`}{`For a short branch, `}<inlineCode parentName=\"p\">{`BRS -3`}</inlineCode>{` will do the same.`}{`)`}</p>\n    </blockquote>\n    <p>{`A short branch can jump within -128 to 127 bytes from the next instruction. A long branch can jump within -32768 to 32767 bytes.`}</p>\n    <h2>{`Absolute`}</h2>\n    <p>{`When loading data, the operand specifies the full 19-bits required to reference any byte within memory space. When branching, the operand specifies 16 bits, which is sufficient for reading and then branching to any location in the first bank `}{`(`}{`which is the only bank that supports code execution`}{`)`}{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`ld a, [0x01234]    # load the word at address 0x01234\nld al, [0x7FFFF]   # load the last byte of memory\nbr [0x2000]        # jump to address pointed to by the word at 0x2000\n`}</code></pre>\n    <h3>{`Indexing`}</h3>\n    <p>{`The address can be indexed by either `}<inlineCode parentName=\"p\">{`X`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`Y`}</inlineCode>{` or both.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`ld x, 0x1000\nld y, 0x0010\nld al, [0x10000, x]     # load the byte from 0x11000\nld al, [0x10000, y]     # load the byte from 0x10010\nld al, [0x10000, x, y]  # load the byte from 0x11010\n`}</code></pre>\n    <p>{`The indexing is always by byte; the width of the destination register has no effect on it.`}</p>\n    <h2>{`Indirect Absolute`}</h2>\n    <p>{`Indirect addressing mode allows one to load data from a location that's pointed at by an absolute address in memory.`}</p>\n    <p>{`When loading or storing data, the absolute address is encoded in 19 bitsâ€”enough to reference every byte of memory. The word that is located at the specified location is then combined with the page of the original absolute address, resulting in a new indirect address. This has the result that you can only access memory indirectly within the same bank as the address through which you are indirecting.`}</p>\n    <p>{`When branching, the absolute address is encoded in 16 bits. The value at that address is then used to look up the new target address. This means that you can only indirect branch within the lowest bank of memory.`}</p>\n    <h3>{`Indexing`}</h3>\n    <p>{`You can index by `}<inlineCode parentName=\"p\">{`X`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`Y`}</inlineCode>{` `}{`(`}{`or both`}{`)`}{` when using the indirect addressing mode, but the final address is determined by the register used for indexing.`}</p>\n    <p>{`When indexing by `}<inlineCode parentName=\"p\">{`X`}</inlineCode>{`, the value of `}<inlineCode parentName=\"p\">{`X`}</inlineCode>{` is added to the absolute address. This enables the ability to index a vector table, for example. The word at the absolute address `}<em parentName=\"p\">{`plus`}</em>{` the `}<inlineCode parentName=\"p\">{`X`}</inlineCode>{` offset will be used as the target address.`}</p>\n    <p>{`When indexing by `}<inlineCode parentName=\"p\">{`Y`}</inlineCode>{`, however, the value of `}<inlineCode parentName=\"p\">{`Y`}</inlineCode>{` is added to the indirected address. This makes it easier to dereference array indices when indirecting through a pointer.`}</p>\n    <p>{`When combining the two, `}<inlineCode parentName=\"p\">{`X`}</inlineCode>{` is first applied to the absolute address, and then `}<inlineCode parentName=\"p\">{`Y`}</inlineCode>{` is applied to the resulting indirect address.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`ld a, 0x1000  \nst [0x02000], a        # address 0x02000 has the value 0x1000\nst [0x03000], a        # so does 0x03000\nld al, 65\nst [0x01000], al       # address 0x01000 has the value 65\nst [0x01010], al\n\nld x, 0x1000\nld y, 0x0010\n\nld al, <0x02000>       # load a with 65 (0x02000 -> 0x01000 = 65)\nld al, <0x02000, x>    # load a with 65 (0x02000 + 0x1000 -> 0x03000 -> 0x01000 = 65)\nld al, <0x02000>, y    # load a with 65 (0x02000 -> 0x03000 + 0x10 -> 0x01010 = 65)\nld al, <0x02000, x>, y # load a with 65 (0x02000 + 0x1000 -> 0x03000 + 0x10 -> 0x01010 = 65)\n`}</code></pre>\n    <h2>{`Relative BP`}</h2>\n    <p>{`When writing functions that take a large number of arguments or a large amount of data, it's useful to reference information stored locally on the stack. This addressing mode enables one to specify an offset from `}<inlineCode parentName=\"p\">{`BP`}</inlineCode>{`, and then reads data from that address.`}</p>\n    <p>{`When branching, this mode only makes sense if the address on the stack points at another function.`}</p>\n    <p>{`The offset from `}<inlineCode parentName=\"p\">{`BP`}</inlineCode>{` can be -32768 to 32767. Given the typical size of the stack, however, this is rarely ever an issue.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`ld al, [bp]        # load the byte at BP\nld al, [bp+-02]    # load the byte at BP - 2 (the + is required syntax)\n`}</code></pre>\n    <h3>{`Indexing`}</h3>\n    <p>{`Indexing `}<inlineCode parentName=\"p\">{`BP`}</inlineCode>{` is also possible, and acts the same as with absolute addressiong.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`ld al, [bp+-10, x]    #start at 10 bytes before BP, index by x, and load\nld al, [bp+-10, y]\nld al, [bp+-10, x, y]\n`}</code></pre>\n    <h2>{`Indirect Relative BP`}</h2>\n    <p>{`As with indrect absolute addressing, one can indirect through a relative `}<inlineCode parentName=\"p\">{`BP`}</inlineCode>{` address:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`ld al, <bp+-2>      # load the byte from the address specified at BP+-2\n`}</code></pre>\n    <h3>{`Indexing`}</h3>\n    <p>{`Indexing with indirect relative `}<inlineCode parentName=\"p\">{`BP`}</inlineCode>{` works the same way as indirect absolute indexing.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`ld al, <bp+-10, x>\nld al, <bp+-10>, y\nld al, <bp+-10, x>, y\n`}</code></pre>\n    <h2>{`Absolute D,X`}</h2>\n    <p>{`This mode is used to enable the combinations of `}<inlineCode parentName=\"p\">{`D`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`X`}</inlineCode>{` to specify any address in the memory space. `}<inlineCode parentName=\"p\">{`D`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`X`}</inlineCode>{` are combined in such a way that they form a 19-bit address, which can then be indexed and offset.`}</p>\n    <p>{`The operation for determining the final operation looks like this:`}</p>\n    <p>{`$$\n\\\\begin{alignedat}{1}\n& D_f & D_e & D_d & D_c & D_b & D_a & D_9 & D_8\n& D_7 & D_6 & D_5 & D_4 & D_3 & D_2 & D_1 & D_0 &   &   &   `}{`\\\\`}</p>\n    <ul>\n      <li parentName=\"ul\">{`&   &   &   & X`}<em parentName=\"li\">{`f & X_e & X_d & X_c & X_b & X_a & X_9 & X_8 & X_7 & X_6 & X_5 & X_4 & X_3 & X_2 & X_1 & X_0`}{`\\\\`}{`\n\\\\hline\n& A`}</em>{`{12} & A`}<em parentName=\"li\">{`{11} & A`}</em>{`{10} & A_f & A_e & A_d & A_c & A_b & A_a & A_9 & A_8 & A_7 & A_6 & A_5 & A_4 & A_3 & A_2 & A_1 & A_0\n\\\\end{alignedat}\n$$`}</li>\n    </ul>\n    <blockquote>\n      <h4 parentName=\"blockquote\">{`Note`}</h4>\n      <p parentName=\"blockquote\">{`If `}<inlineCode parentName=\"p\">{`X`}</inlineCode>{` is not supplied, `}<inlineCode parentName=\"p\">{`0`}</inlineCode>{` is assumed. As such `}<inlineCode parentName=\"p\">{`ld al, [d]`}</inlineCode>{` will load from the address`}<inlineCode parentName=\"p\">{`d<<3`}</inlineCode>{`.`}</p>\n    </blockquote>\n    <p>{`There's no established requirement to determining which bits should go in `}<inlineCode parentName=\"p\">{`D`}</inlineCode>{` and which should go in `}<inlineCode parentName=\"p\">{`X`}</inlineCode>{`, so use whatever makes sense for the algorithm at hand. Typically, however, you'll usually load the top 16 bits of the address in `}<inlineCode parentName=\"p\">{`D`}</inlineCode>{` and the bottom three bits in `}<inlineCode parentName=\"p\">{`X`}</inlineCode>{` to ensure that you can continue to index by `}<inlineCode parentName=\"p\">{`X`}</inlineCode>{` should you need to do so.`}</p>\n    <p>{`Often this looks like this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`.segment data 0x03000 {\n    hello: .string \"Hello, world\"\n           .byte 0\n}\n\n.segment code 0x02000 {\n    ld d, data.hello >> 3\n    ld x, data.hello & 7\n    ld al, [d, x]           # al is now \"H\"\n}\n`}</code></pre>\n    <h3>{`Indexing`}</h3>\n    <p>{`Should you wish to index, you can adjust `}<inlineCode parentName=\"p\">{`X`}</inlineCode>{`, or index additionally with `}<inlineCode parentName=\"p\">{`Y`}</inlineCode>{`.`}</p>\n    <h3>{`Offsetting`}</h3>\n    <p>{`Like in Relative `}<inlineCode parentName=\"p\">{`BP`}</inlineCode>{` addressing, you can add an additional constant offset to `}<inlineCode parentName=\"p\">{`D`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`ld al, [d+1000, x]\n`}</code></pre>\n    <h2>{`Indirect D,X`}</h2>\n    <p>{`It is possible to indirect through any word in memory space using `}<strong parentName=\"p\">{`Indirect D,X`}</strong>{`. Just like any mode of indirection, the resulting bank will always be the same as the original absolute address `}{`(`}{`or `}<inlineCode parentName=\"p\">{`0`}</inlineCode>{` when branching`}{`)`}{`. The method for determining the initial absolute address is the same as `}<strong parentName=\"p\">{`Absolute D,X`}</strong>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`.segment strings 0x50000 {\n    hello: .string \"Hello, World\"\n           .byte 0\n    score: .string \"Score\"\n           .byte 0\n    level: .string \"Level\"\n           .byte 0\n    vectors:\n        .word[3] hello, score, level\n}\n\n.segment code 0x02000 {\n    ld d, strings.vectors >> 3\n    ld x, string.vectors & 7\n    ld al, <d+2,x>           # al has \"S\"\n}\n`}</code></pre>\n    <h3>{`Indexing`}</h3>\n    <p>{`Indexing with Indirect D, X is similar to indirecting with any other addressing mode in that `}<inlineCode parentName=\"p\">{`Y`}</inlineCode>{` is applied after determining the indirect address.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`ld al, <d,x>, y\n`}</code></pre>\n    <h3>{`Offsetting`}</h3>\n    <p>{`A constant offset can be added to `}<inlineCode parentName=\"p\">{`D`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`ld al, <d+2, x>\n`}</code></pre>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;\n"]}
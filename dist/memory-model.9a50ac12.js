parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"QwhI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=m;var e=a(require("react")),t=require("@mdx-js/react");function a(e){return e&&e.__esModule?e:{default:e}}function n(){return(n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}const r=e=>(function(a){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,t.mdx)("div",a)}),l={},i="wrapper";function m({components:e,...a}){return(0,t.mdx)(i,n({},l,a,{components:e,mdxType:"MDXLayout"}),(0,t.mdx)("h1",null,"BASIC Memory Model"),(0,t.mdx)("p",null,"Retroputer BASIC emulates certain aspects of early versions of BASIC while\ndispensing with certain restrictions due to memory size. As such the memory\nmodel is a mix of various techniques, not all of which would have made\nsense within the environment a BASIC from the 80's and 90's would have\nfound itself in."),(0,t.mdx)("h2",null,"Memory Use"),(0,t.mdx)("p",null,"Retroputer BASIC uses the majority of the Retroputer's 512KB of memory. This is\nsimply down to making the assembly language a little bit easier, while also\nallowing for larger programs than would have typically fit within an 8-bit\nmicro of the era. As such, while some decisions feel like a huge waste of\nmemory, they are also implemented either for simplicity or for performance."),(0,t.mdx)("p",null,"The high-level memory map looks like this:"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"Start"),(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"End"),(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"What"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x00000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x01FFF"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"System traps, stack, and kernel state")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x02000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x0549B"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Variable storage and pointers")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x0549C"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x057FF"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Free")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x05800"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x0AFFF"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Safe area for machine language")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x0B000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x0B7FF"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"BASIC state")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x0B800"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x0BFFF"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"MONITOR state (@todo: may remove)")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x0C000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x0FFFF"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Mirror of ROM from 0x7C000-0x7FFFF")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x10000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x1FFFF"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Screen data")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x20000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x20000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Unused")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x20001"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x2FFFF"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Data heap")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x30000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x3FFFF"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Line number pointers")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x40000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x40000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Unused")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x40001"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x4FFFF"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Program code heap")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x50000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x50000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Unused")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x50001"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x5FFFF"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Reserved for garbage collection")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x60000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x6FFFF"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Free")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x70000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x7FFFF"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"ROM")))),(0,t.mdx)("h3",null,"Variable Storage"),(0,t.mdx)("p",null,"Retroputer BASIC supports four types of variables:"),(0,t.mdx)("ul",null,(0,t.mdx)("li",{parentName:"ul"},"16-bit Integer (default, no sigil)"),(0,t.mdx)("li",{parentName:"ul"},"64-bit Floating Point (uses ",(0,t.mdx)("inlineCode",{parentName:"li"},"#")," sigil)"),(0,t.mdx)("li",{parentName:"ul"},"8-bit character strings (uses ",(0,t.mdx)("inlineCode",{parentName:"li"},"$")," sigil)"),(0,t.mdx)("li",{parentName:"ul"},"Functions and Subroutines")),(0,t.mdx)("p",null,"Aside from functions and subroutines, each type can also be supported as an\narray of items. Note that BASIC does not support variant types within an\narray; items must all be of the same type."),(0,t.mdx)("p",null,"Variable names can be any length, up to the allowed line limit, but only the\nfirst two characters are significant. This is a restriction often found on\nBASICs of the era, but it also enables us to use this to our benefit when it\ncomes to performance improvements."),(0,t.mdx)("p",null,"Variable names must start with a letter (",(0,t.mdx)("inlineCode",{parentName:"p"},"_")," is not permitted). Additional\nletters maybe letters or digits. Because of this, there are a total of 924\nvariables of each type that can be supported. (26 * 36 + 26)"),(0,t.mdx)("p",null,"Non-array variables are stored starting at 0x02000 as follows:"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"Type"),(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"Start"),(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"End"),(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"Length"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Integer"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x02000"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x02783"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x784")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"String"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x02784"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x02F07"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x784")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Floating Point"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x02F08"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x0368B"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x784")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"SUBs and FNs"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x0368C"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x03E0F"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x784")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Integer Arrays"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x03E10"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x04593"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x784")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"String Arrays"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x04594"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x04D17"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x784")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Floating Point Arrays"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x04D18"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x0549B"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"0x784")))),(0,t.mdx)("p",null,"Looking up a variable is fast, once you know its type. During line crunching\nBASIC will compute the index of any variables and store it as part of the\ntoken. Adding it to a given base results in the variable's location in memory."),(0,t.mdx)("p",null,"A variable name is directly mapped to a location in memory using the following\nalgorithm:"),(0,t.mdx)("ul",null,(0,t.mdx)("li",{parentName:"ul"},'Single-letter variables come first (0-25) where the index is the letter\nminus the RetSCII character "A".'),(0,t.mdx)("li",{parentName:"ul"},'Variables with two letters combine the first and the second to form the\nindex. The first must be a letter, and so can follow the same pattern as\nsingle variables (0="A",25="Z"). This value is then multiplied by 36 to make\nroom for the next letter or digit, and is also advanced past the first 26\nsingle-letter variables. Again "A"-"Z" get assigned values 0-25, with "0"-"9"\nassigned 26-35. When added together, you get the variable ',(0,t.mdx)("em",{parentName:"li"},"index"),". "),(0,t.mdx)("li",{parentName:"ul"},"A simple shift left will result in multiplying the index by two, resulting in\nan offset that can be added to the base for the given type to read the\nvariable's value.")),(0,t.mdx)("p",null,"Because the above calculation is done at crunch-time, variable lookup can be\ndone with much faster performance than many BASICs of the time (which had to\nsearch through a linked list to find a variable). Of course, this wastes a not\ninsignificant amount of memory -- it's unlikely that anyone will use the entire\nset of variables. Because we have so much memory to spare, however, it makes\nsense to enable some added performance."),(0,t.mdx)("p",null,"The value of each variable is either the value itself in the case of an integer\nor a pointer to where the variable's value is actually stored. Pointers and\nintegers are the same width (two bytes), and so the variable tables are the\nsame size for all types."),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"Type"),(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"Stored Value"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Integer"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"16-bit value")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"String"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Pointer to string in the heap")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Floating Point"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Pointer to 64-bit float in the heap")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"SUBS and FNs"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Associated line number in program storage")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Arrays"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Pointer to contiguous block in the heap")))),(0,t.mdx)("h3",null,"Safe Area for Machine Language Routines"),(0,t.mdx)("p",null,"Given that variables take up just over 13K, and the start of BASIC state begins\nat 0xB800, this leaves roughly 28K free storage in page zero for machine\nlanguage code. To be safe, though, machine code should be located between\n",(0,t.mdx)("inlineCode",{parentName:"p"},"0x05800")," and ",(0,t.mdx)("inlineCode",{parentName:"p"},"0x0B000"),", giving 22K available space. BASIC will not modify the\ncontents of this area."),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},"Note: If you adjust the memory map (",(0,t.mdx)("inlineCode",{parentName:"p"},"MM"),") register, you can use memory above\n",(0,t.mdx)("inlineCode",{parentName:"p"},"0x0B000"),", but you'll need to supply your own kernel. You can copy the kernel\nin ROM from ",(0,t.mdx)("inlineCode",{parentName:"p"},"0x7C000")," to your target using DMA and then switch the memory map\nas desired, but the kernel does often expect to be able to utilize portions\nof memory in the ",(0,t.mdx)("inlineCode",{parentName:"p"},"0x0B000"),"-",(0,t.mdx)("inlineCode",{parentName:"p"},"0x0BFFF")," range.")),(0,t.mdx)("h3",null,"Heap Storage"),(0,t.mdx)("p",null,"Floating point numbers, strings, and arrays are all stored on the heap. The\nheap consumes the entirety of bank 2, meaning that there's only room for 64K of\nthis kind of data."),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},"Note: the first byte in bank 2 is not used, because we use NUL to signify\nthe NULL pointer.")),(0,t.mdx)("p",null,"The heap is managed very simply. A state variable in page 0 manages the highest\naddress used by the heap, and simply writes new data to that location and\nadvances the address appropriately. This means that certain operations will\nrapidly fill the heap with garbage. As such, BASIC will need to perform some\ngarbage collection in order to compact the heap to enable more data to be\nstored. If you want the best performance, avoid operations that require string\nconcatenation, manipulation, or the re-creation of arrays."),(0,t.mdx)("p",null,"Once the heap is full, a temporary bank will be used for the garbage collection.\nBASIC will go through every variable that can be on the stack, and copy the\ndata to contiguous locations. When done, this temporary bank will be copied back\nto bank 2 and execution can resume. Bank 5 is used for garbage collection\nroutines, and so it's inadvisable to store any important data there, unless you\nknow you'll never need garbage collection."),(0,t.mdx)("p",null,"For arrays, the heap is often hit twice -- once for the pointers themselves and\nthen another time for the actual data. As such, different types take up very\ndifferent amounts of heap space."),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"Array Type"),(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"Space Required"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Integer Array"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"2 (for bounds) + size * 2")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"String Array"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"2 + size ",(0,t.mdx)("em",{parentName:"td"}," 2 + new allocations ")," 2")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Floating Point Array"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"2 + size ",(0,t.mdx)("em",{parentName:"td"}," 2 + size ")," 8")))),(0,t.mdx)("blockquote",null,(0,t.mdx)("p",{parentName:"blockquote"},"Note: although the initial set of array's pointers to items are contiguously\nallocated on the heap, that doesn't mean that additional allocations are\nalso contiguous. Strings, for example, can be allocated at any time and may\nnot be particularly close to the original pointer table.")),(0,t.mdx)("p",null,"Looking up a value often requires some degree of indirection, as illustrated\nbelow:"),(0,t.mdx)("table",null,(0,t.mdx)("thead",{parentName:"table"},(0,t.mdx)("tr",{parentName:"thead"},(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"Variable Type"),(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"Initial Value"),(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"Indirection"),(0,t.mdx)("th",n({parentName:"tr"},{align:null}),"Second Indirection"))),(0,t.mdx)("tbody",{parentName:"table"},(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Integer"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Integer"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"N/A"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}))),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"String"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"HEAP Pointer"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"NUL-terminated string"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}))),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Floating Point"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"HEAP Pointer"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"64-bit floating point value"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}))),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"FN or SUB"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Line Number"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"N/A"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}))),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Integer Array"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"HEAP Pointer"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Integer value (at 2+index * 2)"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}))),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"String Array"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"HEAP Pointer"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"HEAP pointer (at 2+index * 2)"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"NUL-terminated string")),(0,t.mdx)("tr",{parentName:"tbody"},(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"Floating Point Array"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"HEAP Pointer"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"HEAP Pointer (at 2+index * 2)"),(0,t.mdx)("td",n({parentName:"tr"},{align:null}),"64-bit Floating Point number")))),(0,t.mdx)("p",null,'As array item pointers are always allocated contiguously, lookup can be very\nfast, but this comes at the cost of memory storage. There must be enough\nmemory after garbage collection on the heap to store all the pointers or values\nfor the given array size. If this isn\'t available, the heap will overflow and\nBASIC will raise an "OUT OF MEMORY" error.'),(0,t.mdx)("h3",null,"Program Storage"),(0,t.mdx)("p",null,"Storage of program code utilizes two banks. Bank 3 (0x30000-0x3FFFF) is used to\nlink line numbers with the crunched code stored in Bank 4 (0x40001-0x4FFFF).\nThe first byte of bank 4 is never used so that BASIC can use ",(0,t.mdx)("inlineCode",{parentName:"p"},"0")," to indicate an\nempty line."),(0,t.mdx)("p",null,"Bank 4 is managed in much the same way as the data heap. New lines are added at\nthe end of storage's free space, and when storage becomes full, garbage\ncollection must occur. Like with the data heap, Bank 5 will be used to compact\nthe code and then copy that code back to Bank 4 (while updating line references\nin Bank 3)."),(0,t.mdx)("p",null,"This means that we're essentially wasting an entire 64K bank with the\nassumption that developers might ever write a program with 32,767 lines of\ncode. This would be very nearly impossible to pull off since most lines of\nBASIC require more than a couple bytes to store in the program code heap. One\nthing this method ",(0,t.mdx)("em",{parentName:"p"},"does")," give us, however, is very rapid lookups for lines\nthemselves. This means that given a line number we can:"),(0,t.mdx)("ul",null,(0,t.mdx)("li",{parentName:"ul"},"Quickly determine if a line exists at that number"),(0,t.mdx)("li",{parentName:"ul"},"Quickly jump to a line number during execution (",(0,t.mdx)("inlineCode",{parentName:"li"},"GOTO"),", ",(0,t.mdx)("inlineCode",{parentName:"li"},"GOSUB"),", etc.)\nwithout the need to search through a linked list")),(0,t.mdx)("p",null,"One thing we ",(0,t.mdx)("em",{parentName:"p"},"can't")," do quickly, however, is sequential execution. Instead\nBASIC must search the line table, skip over NUL pointers, and then pick up\nexecution at the next non-NUL pointer it sees. For a program with a lot of\nspace between line numbers, this would impact performance. Generally, however,\nthe typical distance between line numbers is 5 or 10 items, and so this isn't\ntoo much of an impact. But if code must go from line 500 to line 1500 without\nan intevening jump, there will be a short delay as the line number counts up."),(0,t.mdx)("h3",null,"Free Storage"),(0,t.mdx)("p",null,"Bank 6 is entirely unused by BASIC, and is available for any forms of storage\nby the developer. It's also possible to use this area for screen data or sprite\ndata as well."))}m.isMDXComponent=!0;
},{"react":"SAdv","@mdx-js/react":"QaRW"}]},{},[], null)
//# sourceMappingURL=/memory-model.9a50ac12.js.map